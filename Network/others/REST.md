# REST api

## Representational State Transfer(REST)

- 인터넷 상 컴퓨터 시스템간의 상호운용성을 제공하는 방법 중 하나
- `www`와 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍쳐의 형식

**즉, REST API는 REST의 아키텍쳐 형식을 지켜서 구현한 API**

## Resource and Representation(리소스와 표현)

### 리소스

`무엇이든 리소스가 될 수 있다`

- 보통 컴퓨터에 저장할 수 있는 무언가로 문서, 데이터베이스부터 사람, 검정색과 같은 개념도 될 수 있다
  - 유일한 제약 조건은 `모든 리소스는 URL을 가져야한다`는 것
- 웹에서 클라이언트와 서버가 대화를 하려면, 그것을 지칭하는 이름이 있어야한다
  - 웹에서는 URL을 사용해 각 리소스에 고유한 주소를 부여한다
  - 즉 무언가에 URL을 부여하면 그게 리소스가 된다
- 클라이언트 입장에서 리소스는 중요하지 않다
  - URL과 표현을 볼 뿐, 직접 리소스를 보는 경우는 없기때문

### 표현

` 석류는 HTTP 리소스일 수 있으나, 웹을 통해 석류를 전송할 순 없다`

- 리소스 자체로는 어떻게 사용해야하는지 알 수 없으며, 따라서 리소스를 유용한 방식으로 나타내는 문서가 제공되야한다
- 즉, `리소스의 현재 상태를 기계가 읽을 수 있는 설명으로 나타낸 것`이 표현(Representation). 
  - 예를 들어, 석류는 리소스지만 석류의 크기와 익은 정도, 석류의 이미지등은 표현이다
- 표현은 리소스에 대한 어떤 정보도 담을 수 있으며, 기계가 읽을 수 있는 어떠한 문서이든 상관없다

### Contents Negotiation

단일 리소스는 많은 표현을 가질 수 있다. 표현은 하나의 리소스의 다른 형식일 수도 있고, 다른 상태일 수도 있다.
클라이언트는 이것들을 어떻게 구분하고 어떻게 원하는 표현을 선택해야할까?

- 클라이언트는 어떤 표현을 원하는지 서버에게 알리기 위해 `요청 헤더(Request Header)`를 사용한다
  - 이 요청 헤더를 통해 표현을 선택하는 걸 `Contents Negotiation`
- 통상적으로 다섯가지 `Accept-*`헤더를 사용한다
  - Accept: Media type
  - Accept-Charset: 서버가 사용했으면 하는 문자 인코딩
  - Accept-Encoding: 문자 인코딩과 관련 없는 압축형태를 제공(gzip)
  - Accept-Language: 언어 태그 
  - Accept-Ranges: 표현 다운로드가 중단되었을 때 사용
---

## REST의 구성

1. 자원(resource) : URI
2. 행위(verb): HTTP method
3. 표현(representations)
   - 어떤 리소스를 http로 전송할 때 어떤 형태로 표현할지를 결정하는 것
   - 즉 표현은 요청이나 응답에서 전달하는 실제 데이터

## REST의 제약조건

1. Client-Server 구조
   - Request & Response 구조
   - 클라이언트는 사용자 인증이나 세션 등의 컨텍스트를 관리하고 서버에 요청
   - 서버는 API를 제공하고, 클라이언트 요청에 응답
   - 개념적 분리를 통한 독립적인 발전 가능성 향상
2. Stateless
   - 무상태성, 즉, 작업을 위한 상태 정보를 따로 저장하거나 관리하지 않는다
   - 서버는 저장이 아닌 요청을 처리하기에 다른 서버로 대체되거나 확장하더라도 기능상에 문제가 없다
3. Cache
   - `HTTP`라는 웹 표준을 그대로 사용하기에 인프라를 그대로 사용가능하고, `HTTP`의 캐싱 기능이 적용 가능
   - 브라우저(클라이언트)에 캐시 가능시간동안 데이터 저장가능
   - 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다
   - `Last-Modified`나 `E-Tag` 사용
4. Uniform Interface
   - URI로 지정한 리소스에 대한 조작을 통일된 인터페이스로 수행하는 아키텍쳐 스타일
5. Layered System
   - REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 유연성을 가질 수 있다
6. Code on Demand(optional): 서버에서 클라이언트로 코드를 통해 데이터 전송가능(javascript)

HTTP API도 위 조건을 대부분 만족하지만, 제대로 지켜지지 못하는 조건으로는 `Uniform Interface`

- 참고
  - [HTTP](../lecture_note/03_http.md)
  - [HTTP Header Cache](../lecture_note/07_http_header_cache.md)

## Uniform Interface

- Identification of resources
  - 리소스 식별, 주소 지정 가능성
  - 하나의 `URI`는 단 하나의 리소스만을 식별한다.
  - 즉, 모든 리소스는 각각 자신의 `URI`를 가져야한다.
- manipulation of resources through representation
  - 표현을 통한 리소스 다루기
  - 표현은 `리소스의 현재 상태 또는 의도하는 상태`를 담고 있고, 클라이언트는 표현을 실제 무언가를 대신해 사용할 수 있다
  - 표현은 생성하는 서버 측 코드에 억매이지 않으므로 서버 구현에 따라 바뀔 필요가 없다
- self-descriptive messages
  - 자기 서술형 메시지
  - HTTP 메시지는 수신자가 이해하기 위해 필요한 모든 정보를 담고 있어야한다
- hypermedia as the engine of application state(`HATEOAS`)
  - 어플리케이션 상태의 엔진으로서의 하이퍼미디어

`Uniform Interface`는 대표적인 위 네가지 제약 조건이 존재하며, 많은 API는 `자기 서술형 메시지(self-descriptive message)`와 
`어플리케이션 상태의 엔진으로서의 하이퍼미디어(HATEAOS)` 조건이 충족되지 않는 경우가 다수 존재한다.

### 자기 서술형 메시지 (Self-descriptive Message)

- `표준 메서드와 미디어 유형을 사용해 의미 체계를 지시하고 정보를 교환한다`  
  - HTTP 요청이 `Content-type header`를 포함하지 않으면 `Entity Body`를 어떻게 파싱해야하는지 알 수 없다 
  - 즉, 메시지를 이해하기 위해 `Media Type`이나 `profile` 같은 다른 문서가 필요하다면, `Content-type`이나 `Link`로 참조를 포함해야 한다
- `응답은 명시적으로 캐시 가능성을 지정한다`
  - 클라이언트가 웹 서버로 부터 응답을 받았을 때, 이를 캐시하는게 맞을까? 한다면 얼마나 오래 해야할까?
  - 클라이언트는 이걸 결정해서는 안되며, 서버는 이 정보를 클라이언트에게 전달해야하는 책임이 있다.

### 어플리케이션 상태의 엔진으로서의 하이퍼미디어(HATEOAS)

필딩 논문 내 개별적인 개념
```text
1. 모든 어플리케이션 상태는 클라이언트 쪽에 유지되며, 상태의 변환은 클라이언트의 책임이다
2. 클라이언트는 HTTP 요청을 보내고 응답을 처리하는 것으로만 어플리케이션 상태를 변경할 수 있다.
3. 클라이언트가 다음에 보낼 요청은 그동안 받은 표현에 있는 하이퍼미디어 컨트롤을 보는 것으로 알 수 있다
4. 따라서 하이퍼미디어 컨트롤이 어플리케이션 상태 변화를 야기하는 힘이다.
```

즉, 어플리케이션의 상태는 `REST APIs must be hypertext-driven`.
- `HATEAOS`는 반드시 해야하는 하는 일이 아닌, 다른 제약 조건들을 충족시킨 결과
- `HTML`의 경우 `<a>` 태그를 통해 이를 만족시킬 수 있다.

### 왜 Uniform Interface가 중요할까?

REST가 만들어진 계기가 서버와 클라이언트간의 독립적 진화를 방해하지 않기 위해서이기 때문
- 웹브라우저가 업데이트 되더라도 기존 웹사이트(서버)는 정상적으로 동작한다
- `self-descriptive`는 서버나 클라이언트가 변경되어도, 메시지만 해석하면 언제나 동작시킬 수 있다
- `HATEOAS`는 어플리케이션 상태 전이가 late-binding 된다
- 즉, 어떤 상태로 전이된 이후에서야 다음 상태가 결정되기에 동적으로 변경할 수 있다.