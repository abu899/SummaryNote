# HTTP Header

## Cache (캐시)

### 캐시가 없을 때

- 데이터 변경이 없는 같은 데이터라도 계속 다운로드 받아야 한다
- 인터넷 네트워크는 pc의 메모리나 하드디스크에 비해 느리고 비싸다
- 브라우저 로딩 속도가 느리기에 느린 사용자 경험

### 캐시가 있다면

- 브라우저 캐시에 데이터를 저장
- 두번째 조회부터는 브라우저 캐시의 유효시간 검증 후 바로 가져와서 사용할 수 있다
- 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다
- 브라우저 로딩 속도가 매우 빠르기 때문에, 빠른 사용자 경험 가능

> 캐시 유효시간 초과  
> 당연히 캐시가 없을 때와 마찬가지로 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다

## 검증 헤더(Last Modified)와 조건부 요청(if-modified-since)

캐시 유효시간이 초과되서 서버에 다시 요청하면 두가지 상황이 발생할 수 있다

1. 서버에서 기존 데이터가 **변경**된 경우
2. 서버에서 기존 데이터가 **변경이 없는** 경우

캐시 만료후에도 서버에서 데이터가 변경되지 않을 수도 있다.
이런 경우 데이터를 전송하는 대신 저장해둔 캐시를 재사용할 수 있지않을까?
- 클라이언트 데이터와 서버 데이터가 다르지 않다는걸 검증하는게 필요하다

### 캐시 유효 시간이 초과했지만 서버의 데이터가 갱신되지 않았다면

- 304 (Not modified) + 헤더 메타 정보만으로 응답한다
  - 이때 바디 정보는 포함할 필요가 없다
- 클라이언트는 서버로 부터 받은 응답 헤더로 가지고 있는 캐시의 메타정보를 갱신하게 된다
  - 또한 캐시에 저장되어 있는 데이터를 재활용 가능
- 결과적으로 불필요한 네트워크 다운로드 없이 **적은 용량의 헤더정보만** 다운로드하게 된다!

### 검증 헤더

- 캐시 데이터와 서버 데이터가 같은지 검증하는 헤더
- Last-Modified, ETag

### 조건부 요청 헤더

- 검증 헤더로 조건에 따른 분기
- If-Modified-Since, If-Unmodified-Since
  - Last-Modified와 사용
- If-Match, If-None-Match 
  - ETag와 사용
- 조건이 만족한다면 200(OK)
- 만족하지 않는다면 304(Not Modified)

#### Last-Modified, if-modified-since의 단점

- 1초 미만의 단위로 캐시 조정이 불가능하다
- 날짜 기반의 정해진 로직을 사용한다
  - 따라서 데이터를 수정하면 날짜가 달라진다
  - 하지만, A->B 수정, 다시 B->A로 수정하는 경우 데이터는 변경이 없지만 날짜가 변경된 경우가 존재할 수 있다
  - 즉, 실제 컨텐츠가 변경되지 않은 경우 전체 데이터를 다시 다운받아야 한다
- 서버에서 별도의 캐시 확인 로직을 관리하고 싶은 경우 사용하기 어렵다
  - 스페이스나 주석 같이 영향이 없는 상황에서는 캐시를 유지하고 싶은 경우

#### ETag, If-None-Match

- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전을 달아둘 수 있다
  - ETag: "v1.0", ETag: hash value
- 데이터가 변경되면 tag를 바꿔어서 변경한다
- 날짜기반이 아닌, ETag만 확인해서 같으면 유지하고 다르면 다시 받을 수 있다
- **캐시 제어 로직을 서버에서 완전히 관리**할 수 있다.
  - 클라이언트가 캐시 메커니즘을 알 수 없음
  - 예를 들어 배포주기에 맞춰 ETag 변경

## 캐시 제어 헤더

### Cache-Control

- Cache-Control: max-age
  - 캐시 유효 시간
  - 초 단위
- Cache-Control: no-cache
  - 데이터는 캐시해도 되지만, 항상 origin 서버에 검증하고 사용해야 한다
    - 여기서 origin 서버란, 중간의 캐시 프록시 서버가 아닌 원래의 서버
    - 즉 항상 조건부 요청을 통해 검증하고 사용하라는 헤더
- Cache-Control: no-store
  - 민감한 정보가 있으므로 저장하면 안된다!
  - 메모리에서 사용하고 최대한 빨리 삭제해야한다

### Proxy Cache (프록시 캐시)

- 예를들어 국내에서 미국에 있는 origin 서버에 매번 접속하려면 거리만큼 시간이 소요된다.
- 따라서 국내에 프록시 캐시서버(public 캐시)를 두고 캐시를 가지고 있다면, 중간에 클라이언트에게 응답을 반환해줌으로써 시간을 아낄 수 있다.
- 추가 Cache-Control
  - Cache-Control: public
    - 응답이 public 캐시에 저장되어도 된다
  - Cache-Control: private
    - 응답이 해당 사용자만을 위한 것이기 때문에, private 캐시(클라이언트)에만 저장되어야 한다
    - default
  - Cache-Control: s-maxage
    - 프록시 캐시 서버에만 적용되는 maxage
  - Age: 60
    - origin 서버에서 응답 후 프록시 캐시 내 머문시간

## 캐시 무효화

캐시를 적용하지 않으면, 캐시가 적용되지 않는게 아니다!
웹브라우저가 임의로 캐싱하는 경우도 존재한다.
```text
Cache-Control:no-cache, no-store, must-revalidate
Pragma: no-cache
```
- Cache-Control: must-revalidate
  - 캐시 만료 후에 최초 조회시 origin 서버에 검증해야한다
  - origin 서버 접근 실패시 반드시 오류가 발생해야한다
    - 504(Gateway Timeout)
  - must-revalidate는 캐시 유효 시간이라면 캐시를 사용하게 된다
- Pragma:no-cache
  - HTTP 1.0 하위 호환
- no-cache vs must-revalidate
  - 둘다 캐시를 프록시 캐시에서 검증하는게 아닌 origin 서버에 검증하는 것은 동일하다
  - 하지만 no-cache의 경우 프록시 캐시에서 origin 서버의 통신 중 네트워크가 순간 단절되어 origin 서버에 접근이 불가능한 경우
  200 (OK)를 반환하는 경우가 존재!!
  - 항상 그런것은 아니지만, 캐시 서버설정에 따라 OK가 반환되어 캐시를 사용하게 될 수도 있다 
  - 반면, must-revalidate의 경우 origin 서버에 접속하지 못한 경우, 항상 504(Gateway Timeout) error를 발생시킨다