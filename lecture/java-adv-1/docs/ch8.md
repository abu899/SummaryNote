# CAS - 동기화와 원자적 연산

## 원자적 연산(Atomic Operation)

연산이 더이상 나눌 수 없는 단위로 수행된다는 의미이다.
즉, 연산은 `중단되지 않고, 다른 연산과 간섭없이 완전히 실행하거나 전혀 실행되지 않는 성질`을 가진다.
`멀티스레드 상황에서는 다른 스레드의 간섭없이 안전하게 처리되는 연산`을 뜻한다.

원자적 연산은 멀티스레드 상황에서 문제가 발생하지 않지만, 원자적 연산이 아닌 경우 synchronized 블록이나
Lock을 이용해 안전한 임계 영역을 만들어야 한다.

## CAS(Compare And Swap, Compare And Set) 연산

### 락 기반 방식의 문제점

- 락이 걸려있는 동안 다른 자원의 접근이 불가능하고 해제를 대기해야 함
- 락을 획득하고 해제하는데 시간이 소요

### CAS

- 락을 사용하지 않고 원자적 연산을 지원하는 방식
- 락을 완전히 대체하는 것은 아니고 작은 단위의 일부 영역을 대체
  - 즉, 기본적으로 락을 사용하고 특별한 경우에 CAS를 사용
- AtmoicXXX 에서는 CompareAndSet 메서드를 통해 해당 연산을 지원 [소스코드](../src/main/java/org/example/thread/cas/CasMainV3.java)

위에서 CompareAndSet은 비교하고 값을 설정하는 두 개의 나눠진 연산으로, 원자적인 연산으로 보이지 않을 수 있다.
하지만, CAS는 `CPU 하드웨어 차원에서 특별하게 두 개의 연산을 하나의 원자적인 연산으로 묶어서 처리`할 수 있게 지원한다.
따라서, 현대 CPU들은 CAS 연산을 위한 명령어를 지원한다.

스레드가 동시에 실행되면서 문제가 발생하는 상황을 스레드가 충돌했다고 표현한다.
CAS는 충돌이 발생할 때 `반복 실행`을 통해 이를 해결하므로 락 없이 데이터를 안전하게 변경할 수 있다.
CAS의 경우 `충돌이 드물게 발생하는 경우에 효과적`이지만, 충돌이 빈번하게 발생하는 경우에는 계속해서 재시도해야하므로 CPU 자원을 많이 소모하게 될 수 있다.
즉, 여러 스레드가 자주 동시에 같은 변수를 변경하려고 시도하는 경우에는 성능상 저하가 발생할 수 있다.

### CAS와 Lock 방식 비교

#### Lock 방식

- 비관적(pessimistic) 접근 방식  
  - 항상 다른 스레드 접근할 것이라는 것을 가정
- 데이터에 접근하기 전에 항상 락 획득
- 다른 스레드의 접근 차단

#### CAS 방식

- 낙관적(optimistic) 접근 방식
  - 대부분의 경우 다른 스레드의 접근이 없다고 가정
- 락을 사용하지 않고 바로 데이터에 접근
- 충돌이 발생하면 그때 재시도

즉, 간단한 CPU 연산에서는 CAS 연산이 효과적이며, 실무적으로는 ms 단위 이하로 실행되는 연산에서 사용하는 것이 좋다.
DB 연산 결과 대기 또는 다른 서버의 요청을 대기하는 경우에는 Lock 방식을 사용하는 것이 좋다.

#### 스핀 락(Spin Lock)

스레드가 락이 해제되기까지 반복문을 계속 실행하는 것을 스핀 락이라고 한다. 이런 방식 스핀 대기(spin-wait) 또는 바쁜 대기(busy-wait)라고 한다.
스핀 락 방식은 짧은 CPU 연산을 수행할 때 효과적이며, 잘못 사용하면 오히려 CPU 자원을 더 많이 사용하게 된다.
즉, 스핀 락 방식은 `자원을 소모하며 반복적으로 확인하는 락 메커니즘`으로 볼 수 있다.

## 정리

### CAS

- 장점
  - 낙관적 동기
    - 락을 걸지 않고도 값을 안전하게 업데이트
    - 충돌이 자주 발생하지 않다고 가
  - 락 프리(lock-free)
    - 락을 획득하기 위한 대기 시간 없음
    - 스레드가 블로킹되지 않음
- 단점
  - 충돌이 빈번한 경우 재시도로 인한 오버헤드 발생
  - 스핀 락과 유사한 오버헤드
    - CAS는 충돌 시 재시도하므로 이 과정이 반복되면 스핀 락과 유사한 성능 저하 발

### 동기화 락

- 장점
  - 충돌 관리
    - 하나의 리소스에 하나의 스레드만 접근
  - 안정성
    - 일관성 있는 동작을 보장
  - 스레드 대기
    - 락을 대기하는 스레드는 블로킹되어 CPU 자원 소모가 거의 없음
- 단점
  - 락 획득 대기시간
    - 스레드가 락을 획득하기 위한 시간 필요
  - 컨텍스트 스위칭 오버헤드
    - 락 획득을 대기하는 시점과 락을 획득하는 시점에 스레드의 상태가 변경되면서 컨텍스트 스위칭이 발생하며 오버헤드가 발생할 수 있음

### 사용 시 고려사항

- 일반적인 상황에서는 동기화 락을 사용하고 아주 특별한 경우에만 CAS를 사용하는 것
- CAS가 더 나은 상황
  - 스레드의 상태가 변경되는 것보다 계속 락을 획득을 반복체크 하는 것이 효율적인 경우
  - 대기시간이 매우 짧은 경우

### 실무 관점

- 대부분의 어플리케이션들은 공유자원을 사용할 때 `충돌하지 않을 가능성이 높다`
  - 한 시간에 백만 건이 들어오는 서비스를 가정
  - 1,000,000 / 60 -> 1분에 16,666 건
  - 16,666 / 60 -> 1초에 277 건
  - CPU가 1초에 처리하는 연산은 수십억건을 계산할 수 있기에 충돌이 발생하는 경우는 몇 십건 이하일 수 있음
  - 따라서, 낙관적 방식이 더 나은 성능을 보임
- 위 예시는 주문수 카운트 같은 단순한 연산의 관점, 나노초 단위의 연산일 수 있음