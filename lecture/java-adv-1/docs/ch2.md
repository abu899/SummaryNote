# 스레드 생성과 실행

## 스레드 시작

### 자바 메모리 구조

#### 메서드 영역

프로그램을 실행하는데 필요한 공통 데이터를 관리하며, `프로그램의 모든 영역에서 공유`한다.

- 클래스 정보 : 클래스의 실행 코드(바이트 코드)
- static 영역
- 런타임 상수 풀

#### 스택 영역

자바 실행 시, 하나의 실행 스택이 생성된다. 각 스택 프레임은 `지역 변수, 중간 연산 결과, 메서드 호출 정보등을 포함`한다.

- 스택 프레임
  - 메서드를 호출할 때 마다 하나의 스택 프레임이 쌓이고 메서드가 종료되면 해당 스택 프레임 제거
- 정확히는 `각 스레드별로 하나의 스택 영역을 가짐`
  - 즉, 스레드 수만큼 스택이 생성

#### 힙 영역

인스턴스와 배열이 저장되는 영역이다. 가비지 컬렉션이 이루어지는 주요 대상이다.

---

## 스레드 생성 - Thread 클래스 상속

스레드를 생성하는 방법은 Thread 클래스를 상속받거나 Runnable 인터페이스를 구현하는 방법이 있다.

HelloThreadMain에서 HelloThread start를 실행하면, HelloThread의 run 메서드가 실행된다.
이때 start로 스레드를 실행해야 별도의 스레드에서 run 메서드가 실행된다.
[소스코드](../src/main/java/org/example/thread/start/HelloThreadMain.java)

- HelloThread 스레드 객체를 생성 후 start()를 실행하게 되면 자바는 `스레드를 위한 별도의 스택 공간을 할당`
  - start() 메서드로 실행해야 스택 공간을 할당받고 스레드가 동작
- 새로운 스택 공간에서 run() 메서드의 스택 프레임을 스택에 올려서 실

### 메서드를 실행하면 스택 위에 스택 프레임이 쌓이는 구조가 된다

- main 스레드의 경우 main 메서드의 스택 프레임을 스택에 올리면서 실행된다
- HelloThread start의 경우 run 메서드의 스택 프레임을 스택에 올리면서 실행된다

### 스레드간 실행 순서는 보장되지 않는다

- 스레드는 동시에 실행되기 떄문에 운영체제의 스케쥴링에 따라 달라지기 때문에 순서를 보장할 수 없다

### start vs run

- run으로 실행하면 main 스레드에서 실행되기 때문에 별도의 스택 공간을 할당받지 않는다
- 따라서 main 스택 위에 run 메서드의 스택 프레임이 쌓이게 된다

### 데몬 스레드(Daemon Thread)

- Non Daemon Thread
  - 사용자 스레드
  - 작업이 완료될 때 까지 실행
  - 모든 유저 스레드가 종료되면 JVM도 종료
- Daemon Thread
  - 보조적인 역할을 하는 스레드
  - 사용자 스레드가 모두 종료되면 `자동 종료`
  - ex) 가비지 컬렉터, 자동 저장, 화면 자동 갱신 등

JVM은 데몬 스레드의 종료를 기다리지 않고 종료된다. 데몬 스레드 여부는 실행 전에 결정해야 하며, Thread의 default는 사용자 스레드이다.
[소스코드](../src/main/java/org/example/thread/start/DaemonThreadMain.java)

--- 

## 스레드 생성 - Runnable 인터페이스 구현

