# 12장. 컴포넌트

컴포넌트는 시스템의 구성 요소로 `배포할 수 있는 가장 작은 단위`이다. 컴파일형 언어에서는 바이너리 파일의 결합체이며,
인터프리터형 언어의 경우 소스파일의 결합체이다.

여러 컴포넌트를 서로 링크하여 실행 가능한 단위 파일로 생성하거나, 서로 묶어서 `.war`로 만든다.
또한 컴포넌트 각각을 `.jar` 나 `.dll` 같이 동적으로 로드할 수 있는 플러그인으로 만들 수도 있다.

> 잘 설계된 컴포넌트는 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다

## 배경

과거에는 명령어를 통해 메모리 주소에 로드할 코드를 생성하라고 컴파일러에게 알려주었다.
그렇기에 초창기에는 메모리 어느 위치에 프로그램을 위치 시킬지 고민해야 했으며, `한번 결정된 뒤에는 재배치가 불가능`했다.

이 시절에 라이브러리 함수는 어플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일 되었다.
바이너리가 아닌 소스코드 형태로 유지되었으며, 장치는 느리고 자원은 한정적이였기에 소스코드 전체를 메모리에 상주 시킬 수 없었다.
라이브러리가 크면 클수록 컴파일 시간을 오래 걸렸고, 이 시간을 줄이기 위해 특정 메모리 위치에 컴파일된 바이너리에 로드시키고,
심벌 테이블을 생성한 후 이를 이용해 어플리케이션 코드를 컴파일 했다.

프로그램과 라이브러리가 사용하는 메모리가 늘어날 수록 단편화는 계속될 수밖에 없었으며 이는 지속가능하지 않았다.

## 재배치성

해결책은 `재배치가 가능한 바이너리`였으며, 지능적인 `로더를 통해` 재배치가 가능한 형태의 바이너리를 생성하도록
`컴파일러를 수정`하자는 것이다. 로더는 재배치 코드가 자리할 위치 정보를 전달받았다.

프로그래머는 함수 라이브러리를 로드할 위치와 어플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었으며,
오직 필요한 함수만을 로드할 수 있게 되었다.

추가적으로 컴파일러는 재배치 가능한 바이너리 내의 `함수이름을 메타데이터 형태로 생성하게 수정`되었다.
프로그램이 라이브러리 `함수를 호출`한다면 `컴파일러는 함수 이름 외부 참조(external reference)`로 생성,
라이브러리 `함수를 정의`하는 프로그램이라면 `컴파일러는 해당 이름을 외부 정의(external definition)`로 생성했다.

이렇게 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크 시킬 수 있게 되었다. 
- 링킹 로더(Linking Loader)의 등장.

## 링커(Linker)

링킹 로더의 등장으로 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할 할 수 있게 되었다.
하지만 프로그램이 커지면서 링킹 로더가 프로그램을 로드하는데 시간이 오래걸리게 되었고 로드와 링크 두 단계로 분리되었다.
프로그래머가 느린 부분(링크 과정)을 맡고, 링커(Linker)라는 별도의 어플리케이션으로 이 작업을 처리했다.
즉, 링커는 링크가 완료된 재배치 코드를 만들어 주었고 로더는 로딩만을 담당했기에 로드가 빨리졌다.

프로그램의 크기가 커지면서 로더는 빨랐지만, 컴파일-링크 시간이 병목현상이 되어갔다. 하지만,
메모리의 발달로 링크 시간이 현저하게 감소하게되었고 여러 공유 라이브러리를 사용할 수 있는 
`컴포넌트 플러그인 아키텍쳐`가 탄생하게 되었다.