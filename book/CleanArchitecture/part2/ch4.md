# 4장. 구조적 프로그래밍

구조적 플그래밍은 제어흐름의 직접적인 전환에 대한 규칙을 부과한다

## 기능적 분해

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었다.
모듈 또한 기능적으로 분해할 수 있으며, 거대한 문제를 고수준의 기능들로 분해하고 이를 다시 저수준의 함수들로
분해할 수 있다. 이렇게 지속적으로 분해된 기능들은 구조적 프로그래밍의 `제한된 제어구조`를 이용해 표현할 수 있다.


## 엄밀한 증명은 없었다

데이크스트라의 프로그램 관점에서 정리에 대한 유클리드 계층구조는 만들어 지지 못했다.
즉, 엄밀한 증명을 통해 고품질 소프트웨어를 생산하기 위한 적절한 방법은 아니다.
하지만, 무언가 올바른지를 증명하는건 수학적 방식이외에 `과학적 방법`이 존재한다.

## 과학적 방법

과학은 근본적으로 수학과 달리 올바름을 절대 증명할 수 없다. 뉴턴의 운동법칙의 예로
이를 실험할 수도 소수점 이하 많은 자리의 정확도로 측정할 수 있지만 이를 수학적으로 증명할 순 없다.
즉, 시험을 통해 경험적인 증거가 쌓이더라도 언젠가 다른 실험을 통해 이것이 `잘못되었음이 밝혀질 가능성이 항상 열려있다`.

수학은 증명 가능한 서술이 참임을 입증하는 원리인 반면, 과학은 서술된 내용이 사실임을 증명하는게 아닌, `서술이 틀렸음을 증명하는 방식`으로 동작한다.
즉, 반례를 들 수 없는 서술이 있다면 목표에 부합할만큼 참이라고 본다. 

## 테스트

`테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수 없다.`

테스트를 통해 프로그램이 잘못되었음은 증명할 수 있지만, 맞다고 보장할 수 없다.
다만, 충분한 테스트는 프로그램이 목표에 부합할 만큼 참이라고 여길 수 있게 해준다.
즉, 최선을 다해 올바르지 않음을 테스트를 통해 진행했지만 이를 실패함으로써 프로그램의 올바름을 보여줄 수 있다.

## 결론

구조적 프로그래밍의 가치는 `프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력`이다.
아키텍쳐 관점에서도 기능적 분해를 최고의 실천법으로 여기는 이유이기도 하다.

소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증(테스트) 가능하도록 만들기 위해 노력해야한다.
이를 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야한다.