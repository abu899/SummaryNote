# 21장. 결론 그리고 자바의 미래

21.1 자바 8의 기능 리뷰

자바 8의 변화가 생긴 이유는 커다란 두 가지 추세 때문이다.

- 멀티코어 프로세서의 파워를 충분히 활용해야 한다는 것
  - 무어의 법칙에 따라 실리콘 기술이 발전하면서 개별 CPU 코어의 속도가 빨라짐
  - 코드를 병렬로 실행해야 더 빠르게 코드를 실행할 수 있다
- 선언형으로 데이터를 처리하는 방식, 즉 간결하게 데이터 컬렉션을 다루는 추세
  - 간결하게 데이터 컬렉션을 처리하려면 불변값을 생산할 수 있는 불변 객체와 불변 컬렉션이 필요

한 코어에서 데이터를 변화시키고 다른 코어에서 이 데이터를 읽으려면 비싼 비용을 치러야하며, 잠금 관련 버그도 많이 발생한다.
하지만, 함수형 프로그래밍을 사용하면 두 가지 추세를 모두 달성할 수 있다.
자바 8의 모습이 기존과 달라진 이유가 바로 이 때문이다.

## 자바 8의 기능 리뷰

### 21.1.1 동작 파라미터화

2장과 3장에서 함수형 프로그래밍ㅇ서 지원하는 메서드로 코드 블록을 전달하는 기법을 자바 8에서 제공함을 배웠다.

- apple -> apple.getWeight() > 150 같은 람다 코드 전달 가능
- Apple::isHeavy 같은 메서드의 메서드 참조를 전달할 수 있음

메서드로 전달되는 값은 Function<T, R>, Predicate<T>, Consumer<T>, Supplier<T> 같은 함수형 인터페이스를 가지며
메서드를 수신한 코드에서는 apply, test 등의 메서드로 코드를 실행한다.

### 21.1.2 스트림

기존 컬렉션에 람다를 활용한 filter, map 등의 메서드를 추가하는 것도 가능했지만,
자바 8에서는 새로운 스트림 API를 만들었다.

컬렉션과 스트림은 어떤 비슷한 점과 다른 점이 있을까?

만약 컬렉션에 세 가지 연산을 적용한다면

- 객체를 매핑
- 조건을 만족하는 합계를 필터링
- 결과를 정렬

즉 컬렉션의 경우 `세 번의 탐색`이 필요하다.

반면 스트림 API는 연산을 파이프라인이라는 게으른 형식으로 연산을 구성하게 된다.
그 결과, 한번의 탐색으로 파이프라인의 모든 연산을 수행할 수 있다.

큰 데이터 집합일 수록 스트림의 데이터 처리 방식이 효율적이며, 메모리 캐시 등의 관점에서도 커다란 데이터 집합일 수록
탐색 횟수를 최소화하는 것이 중요하다.

멀티코어 CU를 활용해서 요소를 처리하는 기능 또한 매우 중요해졌다.
이때, `상태 변화`는 병렬성의 가장 큰 걸림돌이 된다. 하지만 스트림은 외부 반복 대신
내부 반복을 지원하는 메서드를 등을 제공하는 함수형 개념의 핵심을 제공하게 된다.

### 21.1.3 CompletableFuture 클래스

자바 5부터 Future 인터페이스를 제공했다. 이를 통해 여러 작업이 동시에 실행될 수 있도록
다른 스레드나 코어로 작업을 할당할 수 있게 되었다.

16장에서는 Future를 구현한 CompletableFuture 자바 8의 클래스를 소개한다.
CompletableFuture와 Future의 관계는 `스트림과 컬렉션의 관계`와 같다라는 걸 명심하자.

- 스트림에서는 파이프라인 연산을 구성할 수 있으며, 동작 파라미터화를 제공한다.
  - 반복자를 사용했을 때 생기는 불필요한 코드를 피할 수 있다
- CompletableFuture에서는 함수형 프로그래밍으로 간결하게 표현할 수 있도록 thenCompose,thenCombine, allOf 등을 제공한다.
  - 명령형에서 발생하는 불필요한 코드를 피할 수 있다

### 21.1.4 Optional 클래스

자바 8 라이브러리는 T 형식의 값을 반환하거나 값이 없음을 의미하는 Optional.empty 메서드를 반환할 수 있다.

Optional<T>를 사용하면 NullPointerException을 피할 수 있다.
또한 스트림 클래스가 제공하는 것과 비슷한 동작으로 계산을 함수형으로 사용할 수 있으며,
값이 없는 것을 코드에서 확인하는 것이 아닌 라이브러리 내부에서 확인할 수 있다.
값을 코드에서 확인 하는 것과 라이브러리 내부에서 확인하는 것은 외부 반복이냐 내부 반복이냐와 같은 의미를 가진다.

자바 9에서는 Optional API에 stream(), or(), ifPresentOrElse() 등의 메서드를 추가했다.

### 21.1.5 Flow API

라바 9에서는 리액티브 스트림과 리액티브 당김 기반 역압력 프로토콜을 표준화했다.
라이브러리가 구현할 수 있는 네 개의 인터페이스 Publisher, Subscriber, Subscription, Processor를 제공한다.

### 21.1.6 디폴트 메서드

자바 8이전에는 인터페이스에서 메서드 시그니처만 정의했지만, 디폴트 메서드가 생기면서 메서드의 기본 구현을 제공할 수 있게되었다.

인터페이스에 새로운 기능을 추가했을 때, 이를 구현한 모든 클래스는 새로 추가된 기능을 구현하지 않을 수 있게되었다.
이는 라이브러리 설계자에게 훌륭한 도구이며 인터페이스가 바뀌어도 사용자는 신경 쓸 필요가 없어졌다.

---

## 21.2 자바 9 모듈 시스템

자바 9의 핵심은 새 모듈 시스템으로 module-info.java 파일이 추가되었지만 언어적으로는 바뀐 것이 없다.
하지만 모듈 시스템 덕분에 아키텍쳐 관점에서 어플리케이션을 설계하고 구현하는 방식이 바뀌었고
하위 부분간의 경계와 상호작용 방법 정의가 명확해 졌다.

하지만 자바 9는 다른 릴리즈와 다르게 적절한 모듈화라는 장점을 얻기 위해 과거 호환성을 해쳤다.
패키지간의 캡슐화 강화는 호환성 희생의 한가지 이유이다.

자바 모듈 시스템의 장점은 다음과 같다.

- 안정적 설정
  - 모듈 요구사항을 명시적으로 선언하여 의존성 누락, 충돌, 순환 등의 문제를 빌드 과정에서 확인할 수 있음
- 강한 캡슐화
  - 특정 패키지만 노출하여 공개할 부분과 내부 구현의 영역을 분리할 수 있음
- 보안성 개선
  - 사용자가 모듈 특정 부분을 사용할 수 없도록하여 보안성 개선
- 성능 개선
  - 클래스가 런타임이 로드된 다른 클래스를 참조하는 것보다 적은 수의 컴포넌트를 참조함하여 최적화 기술이 더 효과적으로 발휘
- 확장성
  - 자바 SE 플랫폼을 작은 부분으로 나눠 실행중인 어플리케이션에 필요한 부분만 사용 가능

---

## 21.3 자바 10 지역 변수형 추론

자바에서는 기본적으로 변수가 메서드를 정의할 때 형식을 지정해야 한다

```text
double convertUSDToGBP(double money) {
  return money * 0.6;
}
```

시간이 지나면서 이런 엄격한 형식 지정이 조금 느슨해졌다. 우선 컨텍스트로 형식을 추론할 수 있는
상황에서는 제네릭의 형식 파라미터를 생략할 수 있게 되었다.
형식이 생략되면 `컴파일러가 생략된 형식을 추론`한다.

```text
Map<String, List<String>> myMap = new HashMap<String, List<String>>();

Map<String, List<String>> myMap = new HashMap<>();
```

---

## 21.4 자바의 미래

### 21.4.3 풍부한 형식의 제네릭

자바 5에서 제네릭이 나왔을 때 기존 JVM과 호환성을 유지해야 했다.
그 결과 List<String>과 List<Integer> 모두 런타임 표현이 같아지게 되었다.
이를 제네릭 다형성의 삭제 모델이라고 하며, 이로인해 런타임에 약간의 비용을 지불하며 `제네릭 형식의 파라미터로 객체만 사용`할 수 있게 되었다.

만일 List<int>를 지원한다면 힙에 List 객체를 할당할 수 있지만, List 컨테이너는 다형석 삭제 모델로 인해
String 같은 객체 값인지 기본형 int 값인지 구별할 수 없게된다.

왜 List 컨테이너가 기본형인지 객체인지를 구별해야하는 이유는 `가비지 컬렉션` 때문이다.
객체를 참조하는 경우 GC가 사용중으로 표시할 수 있지만 기본 값인 경우 GC를 수행할 수 없기에
컨텐츠의 형식 정보를 확인할 수 없는 것이 문제가 될 수 있다.

자바처럼 선언이 다형성 삭제 모델로 인해 모두 같은 형식을 가진다면 가비지 컬렉션이 필드가 참조인지 기본형인지 알 수 있도록
충분한 형식 정보를 런타임에 유지해야한다. 이를 제네릭 다형성 구체화 모델 또는 구체화된 제네릭이라고 부른다.
