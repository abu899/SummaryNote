# 5장. 서비스 설계 원칙

## 5.1 아키텍쳐

### 5.1.1 모던 아키텍쳐 스타일

최근 대부분의 웹 시스템에서 백엔드는 REST API를 제공하고 프론트엔드는 SPA구조로 개발한다.

#### REST API

REST API는 전송방식이 효율적이지 않고 정교한 표준도 없지만, 구조가 간단하고 누구나 쉽게 사용할 수 있는 장점이 있다.
또한 REST API를 대체할 수 있는 프로토콜을 사용하기도 하는데, 다양한 검색조건을 전달할 수 있는
GraphQL, 대용량 데이터를 전송할 떄 효율적인 gRPC 등이 있다.

#### Single Page Application(SPA)

SPA는 하나의 웹페이지에서 자바스크립트가 모든 화면을 동적으로 작성하는 웹 어플리케이션이다.
SPA는 하나의 페이지가 모든 화면의 코드를 로딩한 후에 브라우저에서 동적으로 화면을 작성한다.

SPA 프레임워크는 Virtual DOM을 사용해 전체 페이지를 로딩하지 않고 일부만 업데이트하므로 속도가 빠르고 깜빡임이 없다.
반면 필요한 리소스를 처음에 다운받기에 초기 구동이 늦고 고정된 페이지가 없으므로 검색 엔진 최적화(SEO) 관점에서는 불리하다.

#### 전통적인 아키텍쳐와의 차이

MVC 아키텍쳐와 SPA & API 서버의 가장 큰 차이점은 MVC의 경우 프레젠테이션 로직을 서버가 직접 담당하지만
SPA & API 서버는 SPA 구조의 웹 어플리케이션에서 담당한다는 것이다.

따라서 MVBC 아키텍쳐의 프레젠테이션 로직은 특정 화면 디자인에 종속되지만, API 서버의 프레젠테이션 로직은
불특정 다수의 클라이언트를 대상을 가정하는 경우가 많다.

모바일 클라이언트와 타 시스템을 연계하는 경우 MVC는 전 레이어에 걸쳐 API 관련 기능을 추가로 개발해야한다.
반면 API 서버는 신규 클라이언트가 기존 API를 그대로 사용할 수 있고, 필요한 경우에 각 클라이언트를 위한
전용 API를 개발할 수 있다.

## 5.2 설계 원칙

단순히 코드와 실행 환경을 나누는 것만으로 모든 변경이 쉬워지고 다른 서비스의 장애로부터 자유로워질 수는 없다.
따라서 서비스로 분리했을 때 얻을 수 있는 실질적인 효과에 대해 살펴봐야한다.

### 5.2.1 서비스 분리 효과와 환계

1. 서비스별로 소스 코드를 분리하므로 크기가 작아지기에 코드를 이해하고 변경하기 쉽다
   - 소스 코드가 분리되더라도 서비스끼리 공유하는 공통 개념이 변경되는 경우 서비스를 변경하면 다른 서비스도 함께 변경해야할 수 있다
   - 단순히 소스 코드를 분리하는 것이 아닌 서비스의 기능을 응집되게하고 다른 서비스와의 결합도를 낮아지도록 설계해야한다

2. 서비스는 각각의 코드와 빌드 파이프라인을 가지므로 다른 서비스와 독립적으로 배포할 수 있다.
   - 서비스가 제공하는 API나 이벤트 모양이 변경되면 이를 사용하는 서비스는 함께 변경되어야 한다
   - 따라서 다른 서비스가 같이 변경될 필요가 없도록 하위 호환성을 보장하거나 일정기간 동안 신규 버젼과 기존 버젼을 모두 제공해야할 수도 있다

3. 서비스는 독립된 실행 환경을 가지므로 한 서비스에 장애가 발생하더라도 다른 서비스에는 영향을 주지 않는다
   - 실행 환경이 분리되어도 서비스가 장애로 멈추면 이 서비스의 API를 사용하는 다른 서비스도 장애가 발생할 수 있다
   - 다른 서비스에 장애가 발생하거나 느려지더라도 문제가 업석나 제한된 기능만 영향을 받도록 해야한다

서비스의 코드와 실행환경을 분리해도 여전히 서로 영향을 주고 받는다. 따라서 구체적인 목적의식을 갖고
세부 디자인에 노력을 기울여야 한다.

### 5.2.2 건전한 의존 관계를 위한 원칙

서비스의 의존 관계는 크게 코드 레벨의 참조와 런타임 레벨 참조로 나눌 수 있다.

- 코드 레벨
  - 다른 서비스의 API나 이벤트 정의를 따르는 것
  - 해당 서비스의 API가 변경될 때 자신도 변경
- 런타임 레벨
  - 실행 중에 다른 서비스의 API나 이벤트를 호출하는 것
  - 다른 서비스의 기능을 호출한다면 해당 서비스에 장애가 생겼을 때 자신도 영향을 받을 수 있음

코드 레벨 참조와 런타임 레벨 참조 대부분 동일한 방향을 갖는다. 하지만 코드 레벨의 참조를 콜백 API와 같은 방법으로 역전시키는 경우
둘의 방향은 반대가 된다. 참조 방향을 제어하여 변경을 쉽게하고 장애 영향을 줄이는 설계원칙은 다음과 같다.

- 서비스 간의 순환 참조는 피해야한다
- 참조를 많이 받는 서비스는 추상화 레벨을 높인다

#### 참조 방향의 제어

앞에서의 의존관계 원칙은 객체지향 설계원칙 중 패키지 결합(coupling) 원칙인 의존성 비순환 원칙, 안정된 의존성 법칙, 안전된 추상화 법칙을
MSA에 맞게 응용한 것이다. 코드 레벨의 참조 관계를 제어하는 대표적인 방법은 의존관계 역전법칙(DIP)를 사용하는 것이다.

### 5.2.3 느슨한 의존관계를 위한 원칙

서비스는 서로 아무런 관계를 맺지 않는게 좋지만 현실적으로는 그럴 수 없다. 따라서 서비스 간의 의존관계를 가능한 약하게할 필요가 있다.

#### 통합 모델링보다는 분산 모델링

일반적으로 데이터 모델링을하면 엔티티가 어떤 업무에서 사용되는지는 고려하지 않고 같은 엔티티의 속성은 하나의 엔티티에 모아놓는다.
이 방법은 데이터 종류별로 하나의 엔티티에 정의되므로 중복되지 않고 체계적으로 관리할 수 있으며 필요한 데이터를 찾기 쉽다.
하지만 MSA에서 이런 구조는 변경을 어렵게 만드는 원인이 된다.

데이터 복제를 통해 서비스 간의 의존관계를 줄이는 방법이 있다. 이때 내부 스키마를 직접 노출하는 것에 유의해야한다.
내부 스키마를 노출하여 CDC(Change Data Capture)를 사용하면 데이터를 동기화할 수 있지만, 내부 스키마가 변경되면 다른 서비스에 영향을 줄 수 있다.

#### 라이브러리보다 코드 복제

코드 중복은 대부분 기피하는 사항이다. 하지만 코드 베이스가 커지고 개발팀이 커지면 중복을 제거하는 것 자체가 부담이 될 수 있기에,
일정 부분 중복을 허용하는 것이 더 효과적일 수 있다.

보통 동일한 기능이 필요한 경우 라이브러리를 사용하는데 독립적으로 나아가는 팀에게는 라이브러리 반영은 의외로 까다로운 작업이다.
따라서 라이브러리를 배포하더라도 각 개발팀이 적기에 반영하기 어려운 상황이라면 코드를 제공하고 각 개발팀이 코드를 복사해서 각자 관리하게 하는 것이 좋다.

#### 버전 관리보다 하위 호환성 유지

서비스가 제공하는 API나 이벤트는 가능한 하위 호환성을 유지해야한다. API가 변경될 때 마다 이를 사용하는
서비스를 같이 변경해야하면 사소한 변경에도 문제가 없는지 확인하고 검증해야한다.
따라서 하위 호환성은 중요한 부분이다.

#### 서비스의 캡슐화 강화

서비스에 v1과 v2로 버전을 나누어 제공하는 경우 서비스의 캡슐화를 강화해야 동시에 버젼을 제공할 수 있다.
예를 들어 내부에 User 클래스를 변경하더라도 userVxDto를 통해 캡슐화된 데이터를 제공한다면
데이터 변환 코드를 통해 각 버젼에 맞는 데이터를 제공할 수 있다.

이처럼 REST API를 외부에 제공하는 시스템에서 응답 결과를 DTO와 내부 엔티티로 분리하는 것은 일반적인 접근방식이다.
하지만 모든 시스템에서 그럴 필요는 없다. 만약 API 자체를 외부 공개가 아닌 어플리케이션 내부에서만 사용햐는 경우 이를 생략할 수 있다.

#### 손상 방지 계층(Anti-Corruption Layer)

사용자 서비스의 API 변경으로 인해 이를 참조하는 서비스의 내부 구현이 영향을 받는 것을 방지하기 위해 ACL을 추가할 수 있다.
ACL은 서비스들이 참조하는 공통 DTO를 제공하고, 이를 사용하는 서비스는 ACL을 통해 데이터를 변환하여 사용한다.

### 5.2.4 요약

지금까지 살펴본 부분을 요약하면 다음과 같다.

1. API를 제공하는 서비스는 해당 API를 사용하는 서비스가 변경되지 않도록 API 하위 호환성을 유지해야 한다
2. API를 제공하는 서비스는 외부 인터페이스와 내부 구현을 분리해 인터페이스 변경없이 내부구현을 변경할 수 있어야 한다
3. API를 호출하는 서비스는 API에서 사용하는 부분에만 관심을 가지고 사용하지 않는 부분의 변경에 있어서는 같이 변경할 필요가 없어야 한다
4. ACL을 적용해 API를 호출하는 코드와 내부 구현을 분리하면 API가 변경되더라도 내부 구현과 테스트 케이스가 같이 변경되는 것을 방지할 수 있다 