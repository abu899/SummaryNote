# 3장. 데이터베이스를 분리한다고?

MSA를 적용하는데 있어 어플리케이션의 의존관계가 복잡해지면 데이터베이스를 분리하는 것이 실질적으로 불가능하고,
개발 난도가 높아지며, 네트워크 통신이 많아져 응답속도가 저하되는 것을 우려한다.
또한, 서비스 간의 네트워크 통신에는 ACID 트랜잭션이 보장되지 않는 점에 대한 걱정 또한 존재한다.

이런 반응을 보이는 이유는 뭘까?

1. 기존에 경험했던 구현 스타일과 MSA 구현 스타일이 다르기 때문에 실제로 어떻게 구현되는지 짐작하기 어렵다
2. 까다로운 구현 이슈가 많이 발생할 것으로 짐작한다

이번 장에서는 이런 부분과 관련한 질문과 답변을 정리한다.

## 질문 1. 서비스 간의 통신이 너무 많지 않을까?

시스템을 독립적인 서비스로 나누면 서비스 간의 네트워크 통신이 너무 많아서 구현하기 어렵다고 생각한다.
실제로 서비스가 서로 API나 이벤트로 통신하기 떄문에 구현의 난이도는 올라가나 서비스가 서로 통신을 하는 빈도는 `생각보다 훨씬 적을 수` 있다.
이런 질문은 SPA와 API 기반으로 구축된 시스템이 어떻게 동작하는지 이해하면 해결할 수 있다.

실제로 SPA로 만들어진 화면에서 서비스는 화면 구성에 관여하지 않기 때문에 여러 서비스의 데이터를
표시하더라도 병렬적으로 처리되며, 네트워크 통신이 늘어나지 않고, 응답 속도에도 영향을 주지 않는다.
각 서비스들은 API를 통해 자신이 담당하는 데이터만을 제공할 뿐이다.

서비스 간 통신 또는 참조가 필요한 부분을 살펴보면 다음과 같다.

1. 업무 내부의 참조
   - 모놀리식에서 MSA로 변환하더라도 해당 케이스의 경우 하나의 서비스 안에 머물기 때문에 기존과 동일하게 구현
2. 업무 간의 참조
   - 참조하고 참조받는 업무가 한 서비스에 배치된다면 기존과 동일하게 구현
   - `서로 다른 서비스에 배치`된다면 서비스 간의 API나 이벤트 통신
3. 공통 데이터나 유틸리티 코드를 참조
   - 유틸리티성 코드는 각 서비스가 복제
   - 공통 기능이나 데이터는 공통 서비스에 배치하여 API로 참조하거나 복제하여 사용

즉 모놀리식에서 MSA로 전환될 때 서비스 간의 통신으로 전환되는 것은 2, 3번 케이스의 일부가 된다.
이처럼 기존 아키텍쳐 스타일과 MSA 스타일의 차이가 커서 동작 방식으로 인해 서비스 통신이 과도하게 늘어날 거라는 오해가 생길 수 있다.

## 질문 2. REST API 참조로 속도가 나올까?

데이터베이스 내부에서 다수의 데이터를 조합하여 조회하는 것보다, 여러 데이터베이스에서 데이터를 조회하여 어플리케이션에서 조합하는 것은
네트워크로 전달하는 데이터 양이 늘어나기 때문에 상대적으로 느려지는 것은 당연하다.
하지만 실질적인 차이는 거의 없고 느리더라도 문제되는 경우는 별로 없다. 실제로 API 조회 속도가 저하되는 사례를 살펴보자.

### API 응답 속도가 느려질 수 있는 경우

앞서 설명했듯 서비스는 UI에 데이터만을 전달하게 되고 병렬로 처리된다.
화면에서 A와 B 서비스는 각각 호출되어 화면에서 조합되는데, 각 서비스의 완료 시간은 개별적으로 처리되기에 느려지지 않는다.
하지만, 예를 들어 B 서비스에서 C 서비스의 데이터를 가져와서 조합하는 작업이 있는 경우 추가적인 API 호출이 발생하게된다.
이때 C 서비스에 조회하는 데이터의 양이 늘어나면 실제 REST API 응답 속도가 저하될 수 있다.

### 많이 느릴 것이라고 생각하는 이유 - 건별 API 요청

B 서비스에서 C 서비스를 N건 조회할 때 부가 정보를 N번 씩 호출하는 상황, 즉 `N + 1 문제`가 발생할 수 있다.
이 경우 상당히 비효율적으로 동작하지만 고속 네트워크 통신이므로 데이터가 적은 경우 문제가 발생하지는 않는다.
하지만 데이터 건수가 많아지면 건수에 비례해 데이터 통신이 늘어나므로 네트워크 부하가 늘어날 수 있다.

### 실제 구현 방식 - 일괄 API 요청
### 실제 구현 방식 - 속도 개선

시스템 운영 중에 거의 변하지 않는 정보들이 존재한다. 이런 정보들은 `캐시`로 저장하고, 캐시된 데이터를 조회하는 방식으로 속도를 개선할 수 있다.
로컬 캐시는 서비스를 실행하는 프로세스의 힙 메모리에 저장되어 빠르게 실행된다.

잘 변하지 않는 공통 데이터는 대부분 로컬 캐시가 가장 적합하다. 분산 캐시를 선호하는 경우도 있는데,
네트워크를 통해 조회하므로 속도가 많이 느리고 단일 장애 지점(SPOF)가 될 수 있기에 지양하는 것이 좋다.

## 질문 3. 자동으로 롤백이 안된다고?

하나의 트랜잭션이 여러 서비스에 걸쳐 발생하면 서비스 사이에는 ACID 트랜잭션이 보장되지 않는다.
여러 서비스에 걸친 트랜잭션이 중간에 실패하면 롤백은 서비스 내부에서만 발생하므로 다른 서비스에서 발생한 트랜잭션을
취소하는 `보상 트랜잭션`을 실행해야한다.

기존에는 DB가 자동으로 롤백하던 부분이 동작하지 않아 어렵게 느껴질 수 있지만, 모놀리식 시스템이
네트워크로 통신 할 때도 마찬가지로 동작한다.

상황에 따라 적절히 보상 트랜잭션을 하거나, 보상 트랜잭션이 불가능한 경우 보상 트랜잭션이
발생하지 않도록 순서를 변경하거나 실패 이후 재시도할 수 있도록 처리해야 한다.

그런데 실제로 `보상 트랜잭션이 필요한 경우는 생각보다 적다`. 서비스는 `응집도를 높게 구성`하기 떄문에
실제로는 서로 참조 관계가 많지 않다. 그중 데이터를 조회하는 비중이 높고 데이터를 변경할 때에도 보상 트랜잭션이 필요한 경우는 일부이다.
보상 트랜잭션이 꼭 필요한 경우에만 적절히 구현하면 된다.

## 질문 4. 동시성 이슈

트랜잭션이 여러 서비스에 걸쳐 발생하면 ACID 트랜잭션이 보장되지 않으며, 여러 트랜잭션이 동시에 실행되었을 때 서로 간섭하지 않도록
보장하는 독립성 또한 영향을 받는다. 동시성 이슈가 발생할 수 있는 사례는 다음과 같다.

1. 여러 사용자가 `같은 레코드`를 읽거나 쓰는 경우
2. `같은 테이블`의 여러 레코드를 읽고 쓰는 경우
3. `다른 테이블`의 레코드를 같이 읽고 쓰는 경우

1, 2번 케이스의 경우 서비스 내부에서 발생하기 때문에 ACID 트랜잭션이 보장되며 3번 케이스를 신경써야한다.

1. 다른 서비스에 저장된 데이터를 기준으로 자신을 변경하는 경우, 해당 서비스의 값을 조회하고
값을 변경하기 직전에 `다른 서비스에 저장된 값이 변경`될 수 있다.

   - 같은 데이터베이스에 있다면 SELECT FOR UPDATE와 같이 Lock을 걸어서 해결할 수 있음
   - 각기 다른 데이터베이스라면 정보를 변경하지 못하게 하는 API를 만들어 해당 정보를 변경하지 못하게하고 내 정보를 업데이트
   - Lock 또한 과다한 경우 전체 시스템 속도가 저하되므로, 모놀리식에서도 어플리케이션 로직으로 제어하도록 권장하는 경우가 많다

2. 여러 서비스의 값을 순차적으로 변경할 때, 다른 사용자가 변경 중인 데이터를 조회하여 서비스의 값이 서로 sync 되지 않을 수 있다
3. 여러 값을 변경하다 문제가 발생하여 원상복구 하는 중에 값을 조회

   - 이런 부분이 문제가 되는 경우, 트랜잭션 중인 값이 조회되지 않도록 데이터의 상태 값을 추가

만약 민감한 데이터를 다루고 정확하게 구현하는 것이 너무 부담된다면 `서비스를 합치거나 경계를 변경하는 것도 고려`해야한다.
