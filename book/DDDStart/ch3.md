# 애그리거트

도메인 객체모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의
고나계를 파악하기 어려워진다. 그 말은 즉, 코드를 변경하고 확장하는 것이 어려워지는 것이다.

복잡한 도메인을 이해하기 쉽게 하려면 상위 수준에서 모델을 볼 수 있어야하는데, 그 방법이 애그리거트이다.
애그리거트는 관련된 객체를 하나의 군집으로 묶어주기에 상위 수준에서 도메인 모델간의 관계를 파악할 수 있게된다.

또한 애그리거트는 일관성을 관리하는 기준이 된다.
애그리거트는 관련된 객체를 모았기 때문에 이에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
즉, 함께 생성되고 함께 제거한다.

[그림 3.3]을 보면 애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
즉, 애그리거트는 독립된 객체 군집이며, 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.

이런 경계를 설정할 때 기본이 되는 것이 도메인 규칙과 요구사항이다.
도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.

주의할 점은, `A가 B를 갖는다` 같은 요구 사항이다. 이는 A와 B를 하나로 묶어야한다고 생각하지만,
무조건적으로 A와 B 가 한 애그리거트에 속한다는 것을 의미하는 것은 아니다.
상품과 상품 리뷰를 예시로 들면, 상세 페이지 내에 상품 리뷰가 존재한다.
하지만 이 둘은 함께 생성되지 않고, 함께 변경되지 않는다. 즉, `변경의 주체`가 다르다.

경험상 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많았고, 두 개이상 갖는 경우는 드물었다.

## 애그리거트 루트

애그리거트는 여러 객체로 구성되어 있기에 한 객체 상태만 정상이면 안된다.
애그리거트에 속한 모든 객체가 `일관된 상태를 유지`하려면 애그리거트 전체를 관리할 주체가 필요하다.
이것이 애그리거트의 루트 엔티티이다. 애그리거트에 속한 객체들은 직접 또는 간접적으로
루트 엔티티에 속하게 된다.

### 도메인 규칙과 일관성

애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
그렇기에 애그리거트 루트는 `애그리거트가 제공해야할 도메인 기능을 구현`한다.
루트가 제공하는 메서드는 `도메인 규칙`에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현되야한다.

그렇기에 애그리거트 `외부에서는 애그리거트에 속한 객체를 직접 변경해서는 안된다`.
물론 외부에서 이를 변경할 수는 있겠지만, 그렇게 하면 일관성을 지키기 위해 상태 확인 로직을 응용 서비스에 구현해야한다.
이렇게 되면 동일한 검사 로직을 여러 응용 서비스에 중복으로 구현할 가능성이 높아진다.
다음 두 가지를 습관적으로 적용하자.

- 단순히 필드를 변경하는 set 메서드를 public 범위로 두지 않는다
- 밸류 타입은 부련으로 구현한다.

### 트랜잭션 범위

트랜잭션 범위는 작을 수록 좋다.

동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야한다.
한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 수 있고,
한번에 여러 애그리거트를 수정하면 전체 처리량이 떨어지게된다.

애그리거트에서 `다른 애그리거트를 변경하지 않는다`는 것을 의미한다.
이는 애그리거트가 자신의 책임 범위를 넘어 다른 애그리거트의 상태까지 관리하는 꼴이된다.
앞서 언급했듯이 애그리거트는 최대한 서로 독립적이어야 한다.

만약 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면, 응용 서비스에서 두 애그리거트를
수정하도록 구현한다.

## 리포지터리와 애그리거트

객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
즉, 애그리거트에 속했지만 각각 `다른 DB 테이블에 저장한다고 해서 각각을 위한 리포지터리를 만들지 않는다`.

애그리거트는 개념적으로 하나이므로, 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.
반대로 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야한다.

## ID를 이용한 애그리거트 참조

ORM 기술 덕분에 애그리거트 루트에 대한 참조를 쉽게 구현 가능하고 이를 사용하면 다른 애그리거트의
데이터를 쉽게 조회할 수 있다. 하지만, 필드를 이용한 애그리거트 참조는 다음 문제가 생길 수 있다

- 편한 탐색 오용
  - 다른 애그리거트 객체에 접근하여 상태를 쉽게 변경할 수 있게 됨
  - 구현의 편리함으로 인해 다른 애그리거트를 수정하려는 생각이 들 수 있음
  - 애그리거트간 의존 결합도를 높여서 애그리거트의 변경이 어렵게 만듬
- 성능에 대한 고민
  - 지연, 즉시 로딩에 대한 고민
  - 조회에 있어서는 즉시 로딩이 유리하지만, 단순 상태 변경에 있어서는 지연로딩이 유리
- 확장 어려움
  - 트래픽이 늘면 도메인 별로 시스템이 분리되고 다른 DB를 사용하게 될 수 있음
  - JPA와 같은 단일 기술을 사용할 수 없음을 의미함

ID를 이용한 애그리거트 참조는 `한 애그리거트에 속한 객체들만 참조`로 연결된다.
따라서, 애그리거트간 물리적인 연결이 제거되어 `모델의 복잡도를 낮출 수` 있다.
또한 애그리거트 간의 의존을 제거하여 응집도를 높여주는 효과도 존재한다.

### ID를 이용한 참조와 조회 성능

ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제 될 수 있다.
한 RDBMS에 데이터가 있다면 조인을 이용해 한번에 모든 데이터를 가져올 수 있지만,
ID 참조 방식은 N+1 문제를 발생시킨다.
이를 해결하기 위해서는 조회를 위한 별도 DAO를 만들고 DAO의 조회 메서드에서
조인을 이용해 한번의 쿼리로 필요 데이터를 로딩하면 된다.

애그리거트마다 다른 저장소를 사용한다면, 조회 성능을 높이기 위해 캐시를 적용하거나
조회 전용 저장소를 따로 구성해야한다.

```text
처음 JPA를 접하면 객체간 모든 연관을 지연로딩과 즉시로딩으로 하고 싶어진다.
하지만 이는 실용적이지 않으며 조회 전용 쿼리를 이용해서도 한번에 데이터를 로딩 가능하다.
```

## 애그리거트 간 집합 연관

애그리거트 간 1:N 관계는 Set과 같은 컬렉션을 이용해 표현 가능하지만,
성능 문제 때문에 애그리거트 간의 1:N 연관을 실제 구현에 반영하지는 않는다.
이런 경우에는 반대편에서 N:1 관계로 연관지어 데이터를 구하면 된다.

## 애그리거트를 팩토리로 사용하기

응용 서비스에 도메인 로직 처리가 노출되는 경우가 생길 수 있다.
도메인 기능을 넣기 위한 별도의 도메인 서비스나 팩토리 클래스를 만들 수도 있지만,
애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에
팩토리 메서드를 구현하는 것을 고려할 수 있다. 애그리거트를 생성할 때 많은 정보를 알아야 한다면, 애그리거트를 직접 생성하지 않고 다른 팩토리에
위임하는 방법도 존재한다.
