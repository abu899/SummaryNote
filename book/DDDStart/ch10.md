# 이벤트

## 시스템간 강결합 문제

외부시스템을 연동하는 경우 두가지 문제가 발생할 수 있다.

첫 번째로는 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야할지이다.
두 번째로는 외부 시스템의 응답 시간이 길어짐에 따라 성능에 문제가 생긴다. 즉, 외부 서비스의 성능에
직접적인 영향을 받게된다.
또한 다른 외부 시스템을 추가할 때 마다 도메인 로직이 복잡해지고 트랜잭션 처리가 더 복잡해진다.

이런 문제는 `바운디드 컨텍스트 간의 강결합` 때문에 발생한다.
이런 강결합을 해결할 수 있는 방법이 이벤트로, 비동기 이벤트를 사용하면 시스템간의 결합을 낮출 수 있다.

## 이벤트 개요

도메인의 상태 변경을 이벤트로 표현할 수 있으며, `~ 할때, ~가 발생하면, 만약 ~ 하면` 등과 같은
요구사항을 이벤트로 구현할 수 있다.

### 이벤트 관련 구성요소

- 이벤트
- 이벤트 생성 주체
  - 엔티티, 벨류, 도메인 서비스와 같은 도메인 객체
  - 도메인 로직을 실행해서 `상태가 바뀌면 이벤트를 발생`시킨다.
- 이벤트 디스패쳐(publisher)
  - 이벤트 생성 주체와 핸들러를 연결해주는 것
  - 디스패처의 `구현 방식에 따라 생성과 처리를 동기 또는 비동기로 실행`하게 된다
- 이벤트 핸들러(subscriber)
  - 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해 원하는 기능을 실행

### 이벤트의 구성

이벤트는 발생한 이벤트에 대한 정보를 담는다

- 이벤트 종류
  - 클래스 이름으로 이벤트 종류를 표현
- 이벤트 발생 시간
- 추가 데이터

핸들러는 디스패처로부터 이벤트를 전달받아 필요한 작업을 수행한다.
이때 핸들러가 작업을 수행하는데 필요한 데이터가 이벤트에 담겨 있어야한다.

### 이벤트 용도

- 트리거
  - 도메인 상태가 바뀔 때 후처리가 필요하다면 후처리를 위한 트리거로 사용
- 시스템 간의 데이터 동기화

## 이벤트, 핸들러, 디스패처 구현

- 이벤트 클래스
  - 이벤트 표현
- 디스패처
  - 스프링이 제공하는 ApplicationEventPublisher 사용
- Events
  - 이벤트 발행, ApplicationEventPublisher 사용
- 이벤트 핸들러
  - 이벤트 수신 후 처리, 스프링 기능 사용

## 비동기 이벤트 처리

이벤트를 이용해 강결합 문제는 처리할 수 있지만, 동기로 처리하는 이벤트는 외부 서비스 영향을 받는 문제는 해결하지 못한다.

이벤트를 비동기로 구현할 수 있는 방법은 다음과 같다

- 로컬 핸들러로 비동기로 실행
- 메시지 큐를 이용
- 이벤트 저장소와 이벤트 포워더 또는 이벤트 제공 API 사용

### 로컬 핸들러 비동기 실행

- @EnableAsync 어노테이션 사용해서 비동기 기능을 활성화
- @Async 어노테이션을 이벤트 핸들러에 붙임

### 메시징 큐 이용

Kafka나 rabbitMQ와 같은 메시징 시스템을 사용하는 방법은 이벤트를 메시지 큐에 저장하는 과정과
메시지 큐에서 이벤트를 읽어와 처리하는 과정은 별도 쓰레드나 프로세스에서 처리된다.

이 경우 이벤트를 메시지 큐에 저장하는 것을 같은 트랜잭션 범위에서 처리해야하는데, 이 때 글로벌 트랜잭션이 필요하다.
하지만, 글로벌 트랜잭션으로 인해 전체적인 성능이 떨어지는 단점도 존재한다.

### 이벤트 저장소를 이용한 비동기 처리

이벤트를 일단 DB에 저장한 뒤 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는 것이다.

이벤트가 발생하면 `로컬 핸들러는 이벤트를 저장소에 저장`한다. 포워더나 이벤트 제공 API를 통해
주기적으로 이벤트 저장소에서 이벤트를 가져와서 이벤트 핸들러를 실행한다.

이벤트 발생과 물리적 저장소에 보관하는 것은 로컬 트랜잭션에서 처리되어 글로벌 트랜잭션이 필요하지 않다.
만약 외부 이벤트 핸들러가 실패하더라도 다시 이벤트 저장소에서 이벤트를 가져와서 실행할 수 있다.

## 이벤트 적용 시 추가 고려 사항

1. 이벤트 소스를 추가할지 여부
   - 특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현할 수 있음
2. 포워더에 전송 실패를 얼마나 허용할 것인가
   - 이벤트 전송에 실패하면 실패한 이벤트부터 다시 시도
   - 계속 실패하는 경우 다음 이벤트를 실행할 수 없기때문에, 재전송 횟수 제한
3. 이벤트 손실
   - 이벤트 저장소를 이용한 방법은 저장소에 이벤트가 보관되기에 문제 없음
   - 하지만 `로컬 핸들러를 이용해 이벤트를 비동기로 처리`하는 경우 이벤트 처리에 실패하면 `이벤트를 유실`하게 된다
4. 이벤트 순서
   - 이벤트 저장소는 이벤트 발생 순서대로 저장하고 제공
   - 메시지 시스템은 사용 기술에 따라 이벤트 발생 순서와 전달 순서가 다를 수 있음
5. 이벤트 재처리
   - 동일한 이벤트를 다시 처리해야 할 때 이벤트를 어떻게 할지 결정

