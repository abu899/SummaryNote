# 7장. 코드를 오용하기 어렵게 만들라

## 이번 장에서 다루는 내용

- 코드 오남용으로 인해 버그가 발생하는 방식
- 코드를 오용하기 쉬운 흔한 방식
- 코드를 오용하기 어렵게 만드는 기술

우리가 작성하는 코드는 서로 다른 코드들과 맞물려 동작한다. 오용하기 쉽게 작성된 코드라면
곧 오용될 가능성이 존재하고 소프트웨어가 올바르게 동작하지 않을 것이다.

애매한 가정에 기반해서 코드가 작성되거나 다른 개발자가 잘못된 일을 하는 것을 막지 못할 때 오용이 발생하기 쉽다.

- 호출하는 쪽에서 잘못된 입력을 제공
- 다른 코드의 부수효과
  - 입력 파라미터 수정
- 정확한 시간이나 순서에 따라 함수를 호출하지 않음
- 관련 코드에서 가정과 맞지 않게 수정이 이루어짐

설명과 코드에 대한 지침은 이런 가능성을 낮춰주지만, 코드 계약의 세부 사항이므로 간과되거나 최신 정보가
아닐 수 있다. 따라서, 코드를 `오용하기 어렵게 설계하고 작성`하는 것이 중요하다.

## 7.1 불변 객체로 만드는 것을 고려하라

객체가 생성되고 바꿀 수 없다면 이는 불변 객체이다. 가변 객체는 다양한 문제가 발생할 수 있다.

- 가변 객체는 추론하기 어렵다
  - 객체의 상태가 변경되는 시점을 추론하기 어렵다
- 가변 객체는 다중 스레드에서 문제가 발생할 수 있다

객체를 불변으로 만드는 것이 항상 가능하지 않고 변화를 추적해야 하는 경우 가변 자료구조는 필요하다.
하지만, 가변 객체는 코드의 복잡성을 늘리고 문제를 일으킬 수 있기에, `기본적으로 불변 객체를 만들되 필요한 곳에서 가변`적인게 바람직하다.

### 7.1.1 가변 클래스는 오용하기 쉽다

클래스를 가변적으로 만드는 일반적인 방법은 setter 함수를 제공하는 것이다.
이런 함수를 제공하게 됨으로써 객체는 가변적이고 해당 인스턴스를 전달받는 모든 코드는 해당
객체를 변경하고 오용할 위험이 존재한다.

### 7.1.2 해결책: 객체를 생성할 때만 값을 할당하라

모든 값이 객체의 생성 시에 제공되고 이후로 변경될 수 없게함으로써 불변 객체로 만들 수 있다.
클래스 외부에서 멤버 변수를 수정할 수 없어야 한다.

### 7.1.3 해결책: 불변성에 대한 디자인 패턴을 사용하라

세터를 제거하고 멤버 변수를 final로 설정하면 불변적이고 버그를 방지할 수 있다.
하지만 이런 경우 클래스가 쓸모가 없어질 수 있으며, 값이 반드시 필요하지 않거나 불변 클래스의 가변 버젼을 만들어야하는 경우의
확장에 어려움이 존재한다. 이를 위한 두가지 패턴이 존재한다.

- 빌더 패턴
- 쓰기 시 복사 패턴

#### 빌더 패턴

생성자를 통해 해당 값을 모두 설정하는 것은 까다로울 수 있으며 이때 빌더 패턴을 사용할 수 있다.

클래스를 생성할 때 일부 값은 필수이고 일부는 선택 사항인 경우가 존재할 수 있다.
빌더 패턴은 값의 일부 또는 전체가 선택 사항인 경우 불변 객체를 생성하는데 유용한 방법이다.

#### 쓰기 시 복사 패턴

클래스의 인스턴스를 변경해야 하는 경우 쓰기 시 복사 패턴을 사용할 수 있다.
이 패턴을 사용하면 기존 객체를 복사하여 값을 변경한 후 복사본을 전달할 수 있다.

## 7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

클래스가 실수로 가변적으로 될 수 있는 경우가 존재하는데 이는 `깊은 가변성` 떄문이다.
멤버 변수 자체가 가변적인 유형이고 다른 코드가 멤버 변수에 액세스하는 경우 발생할 수 있다.

### 7.2.1 깊은 가변성은 오용을 초래할 수 있다

대표적으로 리스트 자료구조를 들 수 있다. 리스트가 내부적으로 final로 선언되었어도 
값이 아닌 `참조를 전달`하기에 다른 함수에 호출됨에 따라 수정이 될 가능성이 존재한다.

일부 코드가 리스트를 수정할 수도 있으며 이를 추적하기는 매우 어렵다.

### 7.2.2 해결책: 방어적으로 복사하라

클래스의 어떤 `객체에 대한 참조를 클래스 외부에서도 가지고 있으면` 깊은 가변성과 관련한 문제가 발생할 수 있다.

이를 방지하기 위해서 getter를 통해 전달하는 객체는 객체의 복사본을 전달할 수 있다.
최선의 해결책은 아니지만 깊은 불변성을 담보하기 위해 가장 간단한 방법이다.

하지만 다음과 같은 단점이 존재한다.

- 복사하는데 비용이 많이 들 수 있다
- 클래스 내부에서 발생하는 변경을 막아주지 못한다

### 7.2.3 해결책: 불변적 자료구조를 사용하라

객체를 불변적으로 만드는 것은 생성되고 나면 변경할 수 없다는 것이다. 복사본을 만들 필요없이
객체를 전달할 수 있음을 의미한다. java에서는 ImmutableList 자료구조를 사용할 수 있다.

## 7.3 지나치게 일반적인 데이터 유형을 피하라

정수, 문자열 및 리스트 같은 간단한 데이터 유형은 코드의 기본 구성요소이다.
이 유형은 다른 모든 것을 대표할 수 있으나,` 데이터 유형 자체만으로는 무언가를 설명할 수 없고
가질 수 있는 값에 대해서도 관대`하다.

### 7.3.1 지나치게 일반적인 유형은 오용될 수 있다

예를 들어 위도와 경도를 나타는 값은 List<Double>로 표현 가능하다. 만약 여러개의 값을 
표현하고자 한다면 List<List<Double>로 표현할 수 있다. 하지만 리스트는 너무나 일반적인 데이터 유형으로 코드를 오용하기 쉽게 만든다.

- List<List<Double>> 유형 자체로는 어떤 설명도 알 수 없다
  - 코드 게약의 세부사항을 읽어보거나 설명을 읽지 않았다면 해당 값들이 어떤 내용인지 알 수 없다
- List내 어떤 값이 위도 또는 경도인지 알 수 없다
  - 즉, 리스트 내의 순서를 혼동하기 쉽고 이를 오용할 수 있다
- 형식 안정성이 거의 없다
  - List 내에 값이 없거나 적을수도 또는 많을 수도 있지만 이를 컴파일러가 알 수 없다

코드 계약의 세부 조항에 대한 자세한 지식없이 함수를 올바르게 호출하는 것은 거의 불가능해진다.

#### 패러다임은 퍼지기 쉽다

한가지 일을 임시로 해놓으면 종종 더 많은 일을 똑같이 할 수 밖에 없어진다.
임시로 작성도니 코드는 다른 개발자들도 같은 방식으로 하지 않고는 이미 작성된 코드와
상호작용하기 어려워지기 떄문에 코드 전반에 퍼지게 된다.

### 7.3.2 페어 유형은 오용하기 쉽다

Pair 데이터 유형의 요점은 동일하거나 다른 종류의 값을 두개 저장하는 것이다.
호출하는 쪽에서 값을 적게 또는 많게 제공하는 것을 방지할 수는 있지만, 앞서 언급한 문제의 일부를 해결할 수 없다.

- List<Pair<Double,Double>>은 여전히 해당 값이 무엇을 의미하는지 알 수 없다
- Pair 내 값의 순서는 여전히 혼동하기 쉽다

### 7.3.3 해결책: 전용 유형 사용

무언가를 나타내기 위해 새로운 클래스를 정의하는 것은 불필요해 보일 수 있다.
하지만 이런 노력은 다른 개발자가 코드를 읽을 때 이해하기 쉽고 버그의 가능성도 줄여준다.

```java
class LatLong {
    private final double latitude;
    private final double longitude;
}
```

일반적인 데이터 유형을 사용하는 것이 빠르고 쉬워보이지만, 무언가 구체적인 것을 나타낼 필요가 있는 경우
적은 노력을 추가로 들여 전용 유형을 정의하는 것이 나을 때가 많다.

## 7.4 시간 처리

시간은 단순한 것처럼 보일지 모르지만 여러가지 고려사항으로 인해 까다로울 수 있다.

- 어떤 때는 몇시 몇분 몇초와 같은 절대적인 시간을 지칭하지만 어떤 때는 5분 내와 같은 상대적인 시간도 존재한다
- 시, 분, 초와 같은 다양한 단위를 통해 시간의 양을 표현할 수 있다
- 표준 시간되, 서머타임, 윤년등 다양한 개념도 존재한다

시간을 다룰 떄는 코드를 잘못 사용하고 혼동을 일으킬 소지가 많다.

### 7.4.1 정수로 시간을 나타내는 것은 문제가 될 수 있다.

시간은 일반적으로 long 타입을 이용해 나타낼 수 있다. 이것은 한순간을 의미하는 시간과
양을 모두 표현할 수 있다.

- 순간으로서의 시간은 유닉스 시간(epoch time)
- 시, 분, 초와 같은 시간의 양

정수는 일반적인 유형이기 떄문에 사용하는 경우 오용이 쉽다.

#### 한순간의 시간인가 아니면 시간의 양인가

```text
// deadline은 초단위
Boolean sendMessage(String message, long deadline) {
}
```

위 예시를 보면 두가지 해석이 가능하다

- 파라미터 deadline은 epoch time을 지칭하여 해당 시간이 데드라인이 된다
- 파라미터 deadline은 시간의 양을 나타내며, 일정 시간의 양이 지나면 만료된다

이런 모호함이 발생하는 경우 주석을 보완하거나 코드 계약 세부조항을 추가할 수도 있지만,
이는 최상의 방법이 아니다

#### 일치하지 않는 단위

시간을 측정하는데는 시, 분, 초, 밀리초 등 여러가지 단위를 사용할 수 있다.
정수 유형은 해당 값이 어떤 단위를 나타내는지 도움이 되지 않는다.

#### 시간대 처리 오류

epoch time은 타임스탬프라고도 부르는데, 해당 값은 위치에 따라 다르게 해석될 수 있다.
서버가 서로 다른 위치에서 실행되고 시스템을 다른 표준 시간대로 설정한 경우 이런 문제가 발생한다.

정수는 값이 의미하는 바나 나타내고자 하는 정보를 거의 전달하지 못하기 때문에 값을 오용하기 쉽게 만든다

### 7.4.2 해결책: 적절한 자료구조를 사용하라

대부분의 언어에서는 시간과 관련된 개념에 대한 유틸리티가 제공된다. 자바에서는
java.time 패키지의 클래스를 사용할 수 있다.

#### 양으로서의 시간과 순간으로서의 시간의 구분

Java.time 클래스에서느 Instant와 Duration이라는 클래스는 각각 순간으로서의 시간과 양으로서의 시간의
개념을 제공한다. 해당 클래스를 사용하면 메서드가 나타내고자 하는 바가 명확해진다.

```text
Boolean sendMessage(String message, Duration deadline) {
}
```

#### 더이상 단위에 대한 혼동이 없다

Instant 및 Duration과 같은 유형은 단위가 유형 내 캡슐화되어 있다는 점이다.
어떤 단위가 사용되어야 하는지에 대한 설명이나 실수로 잘못된 단위를 제공하는 것이 불가능하다.

#### 시간대 처리 개선

## 7.5 데이터에 대해 진실의 원천은 하나만 가져야 한다

데이터는 종종 두가지 형태로 제공된다.

- 기본 데이터(credit, debit)
  - 코드에 제공해야 할 데이터
  - 코드에 이 데이터를 알려주지 않으면 코드가 처리할 방법이 없음
- 파생 데이터(balance)
  - 주어진 기본 데이터에 기반하여 코드가 계산할 수 있는 데이터

기본 데이터는 일반적으로 프로그램에서 진실의 원천(resource of truth)이다.

### 7.5.1 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다

은행 게좌의 잔고는 credit과 debit을 통해 계산할 수 있다(credit - debit).
credit이 5이고 debit이 3이면 잔고는 2여야 하지만, 10인 상황이 발생할 수 있을까?

만약 기본 데이터와 파생 데이터를 모두 처리하는 코드를 작성하는 경우 이런 논리적으로 잘못된 문제가 발생할 수 있다.

```java
class Account {
    private final int credit;
    private final int debit;
    private final int balance;
  
    Account(int credit, int debit, int balance) {
        this.credit = credit;
        this.debit = debit;
        this.balance = balance;
    }
}
```

```text
Account account = new Account(credit, debit, debit - credit);
```

위 예시는 인스턴스 생성 시 balance를 계산하는 것이 아닌 파라미터로 받아들이고 있으며,
인스턴스 생성 시 잘못 계산된 값이 대입되는 문제가 발생할 수 있다.

### 7.5.2 해결책: 기본 데이터를 유일한 진실의 원천으로 사용하라

잔액을 위한 별도의 필드를 갖는 것은 중복이다. 이런 경우에는 중복을 제거하고,
잔액을 위한 필드를 제거하고 메서드를 통해 이를 계산하여 전달 할 수 있다.

더 복잡한 상황에서는 예기치 못한 상황이 발생할 수 있기 때문에, 정의할 수 있는 데이터 모델과
이런 데이터 모델이 잘못된 상태를 허용하는지에 대해 고민해야한다.

#### 데이터 계산에 비용이 많이 드는 경우

떄로는 파생된 값을 계싼하는 게 많은 비용이 들 수 있다. 이런 경우 지연 계산 후 결과를 캐싱하는 것이 좋다.
필요할 때 까지 계산을 미루고 결과를 캐싱함으로써 비용을 줄일 수 있다.

이 상황에서 객체가 불변이 아니라면 상황이 복잡해 질 수 있으므로, 이런 객체를 불변으로
만드는 것을 권장한다.

## 7.6 논리에 대한 진실의 원천을 하나만 가져야 한다

진실의 원천은 코드에 제공된 데이터 뿐만 아니라 코드에 포함된 논리에도 적용된다.

### 7.6.1 논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다

예를 들어 정수값을 기록한 후 파일로 저장하는 클래스가 존재한다.

해당 코드의 저장 방식은 두가지 세부 정보가 존재한다.

1. 각 값은 10진수 문자열 형식으로 변환
2. 이후 각 값의 문자열을 쉼표로 구분

마찬가지로 해당 파일을 열고 다시 정수로 읽어들이는 코드는 다음과 같다.

1. 문자열을 쉼표로 구분해 문자열의 목록을 읽는다
2. 목록의 각 문자열을 10진수로 변환한다

위와 같은 클래스가 각각 존재하게 되면 파일이 저장되는 형식에 대한 논리(10진수 변환, 쉼표로 구분)가 두 곳에서 존재하게 된다.
각 클래스가 동일한 논리를 가지고 있다면 문제가 없지만, 한 쪽 클래스에서 논리가 변경된다면 문제가 발생한다.

### 7.6.2 해결책: 진실의 원천은 단 하나만 있어야 한다.

데이터를 저장하고 로드하는 등의 상위 수준의 문제를 하위 문제를 만들어 해결하는 방식으로 진행할 수 있다.
즉, 정수 목록을 직렬화, 역직렬화 하는 하나의 코드 계층으로 구현한다면 하나의 진실의 원천을 가질 수 있다.

두 개의 다른 코드가 수행하는 논리가 서로 일치해야 할 때, 다른 부분에 있는 코드가 내포하고 있는 가정을
인식하지 못할 수 있다. 이 경우 진실의 원천이 하나가 되도록 하면, 서로 다른 코드들이
일치하지 않아 발생할 수 있는 버그의 위험을 제거할 수 있다.

## 요약

- 코드가 오용되기 쉽게 작성되고나면 어느 시점에선가 오용될 가능성이 크고 이것은 버그로 이어진다
- 코드가 오용되는 몇가지 일반적인 사례는 다음과 같다
  - 호출하는 쪽에서 잘못된 입력을 제공
  - 다른 코드에서 일어나는 부수 효과
  - 함수 호출 시점이 잘못되거나 순서가 잘못된 경우
  - 원래 코드에 연관된 코드를 수정할 때 원래 코드가 내포한 가정과 어긋나는 경우
- 오용이 어렵거나 불가능하도록 코드를 설꼐하고 구조화하는 노력을 기울이자
