# 10장. 단위 테스트의 원칙

## 이 장에서 다루는 내용

- 단위 테스트의 기본 사항
- 좋은 단위 테스트가 되기 위한 조건
- 테스트 더블
- 테스트 철학

코드가 처음 작성될 때 그리고 수정될 때 마다 코드가 의도한 대로 동작하는 것을 확신하기 위해 테스트를 사용할 수 있다.

단위 테스트는 `상대적으로 격리된 방식`으로 코드의 구별되는 단위를 테스트하는 것에 관한 것이다.
상대적으로 격리된 방식은 다양한 해석의 여지가 있으며 테스트 대상에 의존하는 코드를 차단하는 방법과
이를 포함해서 테스트하는 방법이 존재한다.

## 10.1 단위 테스트 기초

단위 테스트와 관련하여 기억해야할 개념들을 정리

- 테스트 중인 코드(code under test)
  - 실제 코드, 테스트의 대상이 되는 코드
- 테스트 코드
  - 단위 테스트를 구성하는 코드
- 테스트 케이스
  - 여러 테스트 케이스가 있고, 각 테스트 케이스는 특정 동작이나 시나리오를 테스트
  - 일반적으로 다음 세 개의 섹션으로 나눌 수 있다
    - 준비
      - 테스트 할 동작을 호출하기 위해 설정을 수행하는 경우
    - 실행
      - 테스트 중인 동작을 실제로 호출하는 코드
    - 단언(assert)
      - 실제로 올바른 일이 발생했는지 확인
      - 반환괎이 예상한 값과 같거나 일부 결과 상태가 예상과 같은지 확인
- 테스트 러너
  - 실제로 테스트를 실행하는 도구

## 10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?

좋은 단위 테스트가 가져야할 5가지 주요 기능

- 훼손의 정확한 감지
- 세부 구현 사항에 독립적
- 잘 설명되는 실패
- 이해할 수 있는 테스트 코드
- 쉽고 빠르게 실행

### 10.2.1 훼손의 정확한 감지

단위 테스트의 목적은 코드가 훼손되지 않았고, 의도한 대로 동작하고 버그가 없다는 것을 확인하기 위함이다.
코드가 어떤 식으로든 훼손되면 컴파일이되지 않거나 테스트가 실패해야 한다.
이는 다음 두가지 역할을 수행한다.

- 코드에 대한 초기 신뢰를 준다
  - 새로운 코드나 코드 변경 사항과 함께 철저한 테스트 코드를 작성하면 코드가 코드베이스로 병합되기 전 실수를 발견하고 수정 가능
- 미래의 훼손을 막아준다
  - 다른 개발자가 코드를 변경하는 과정에서 실수로 코드를 훼손할 수 있다
  - 모든 테스트가 올바르게 동작하는 것으로 이를 판별할 수 있다
  - 잘 돌아가던 기능이 작동하지 않는 것을 회귀(regression)
    - 회귀를 탐지할 목적으로 테스트를 실행하는 것을 회귀 테스트

대상 코드가 실제로 훼손된 경우에만 테스트가 실패해야한다.

> 코드가 훼손되면 반드시 실패한다 != 코드가 훼손될 때만 테스트가 실패한다

대상 코드가 `정상임에도 불구하고 실패하는 테스트`를 `플래키(flakey)`라 한다.
보통 무작위성, 타이밍 기반 레이스 조건, 외부 시스템에 의존하는 등의 테스트의 `비결정적(indeterministic) 특성으로 인해 발생`한다.
아무것도 아닌 이유로 실패하기에 테스트가 계속 실패함에 따라 이내 경고를 무시하게 될 수 있다.
따라서, 코드에서 어떤 부분이 훼손될 때 그리고 오직 훼손된 경우에만 테스트가 실패하도록 하는 것은 매우 중요하다.

### 10.2.2 세부 구현 사항에 독립적

코드베이스에 변화가 있는 경우는 다음과 같다.

- 기능적 변화
- 리팩토링

기능적 변화의 경우 코드를 사용하는 `모든 사람에게 영향`을 미치므로 변경을 하기전에 코드를 호출하는 쪽을
신중히 고려해야한다. 이 경우는 테스트도 수정해야 할 것으로 예상한다.

리팩토링의 경우 코드를 사용하는 사람에게 영향을 미치지 않아야 한다.
하지만 구조 수정만을 한 것인데 그 과정에서 실수로 동작을 변경하지 않았다고 어떻게 확신할 수 있을까?
이를 위해 단위 테스트를 작성할 때의 두 가지 접근 방식을 고려해보자.

- A 방식
  - 테스트는 모든 동작 뿐만 아니라 구현 세부 사항도 확인해야한다
  - 프라이빗 변수 및 의존성을 직접 조작하여 상태를 시뮬레이션하고, 다양한 멤버 변수의 상태를 검증
- B 방식
  - 동작만 테스트하고 구현 세부 사항은 확인하지 않는다.
  - 프라이빗 변수나 함수를 사용하여 어떠한 것도 조작하거나 검증하지 않는다.

리팩토링을 올바르게 수행할 경우 `구현 세부 정보만 변경`되어야 하며 외부의 동작에는 영향을 미치면 안된다.
이 경우 서로 다른 테스트 방식을 사용한 경우 어떤 결과가 발생할까?

- A 방식
  - 리팩토링의 올바른 수행과 별개로 테스트가 실패
  - 테스트를 다시 통과하려면 테스트 코드를 많이 변경해야 한다
- B 방식
  - 테스트 코드를 수정할 필요 없이 테스트는 여전히 통과

이처럼 테스트가 구현 세부 사항에 의존하지 않는다면 리팩토링의 실수가 있었는지 확인해주는 테스트 결과를 신뢰할 수 있다.

#### 기능 변경과 리팩토링을 같이 하지 말라

리팩토링은 어떠한 동작도 변경하지 않지만, 기능 변경은 동작을 변경한다.
이 두 가지를 동시에 하면 기능 변화로 인한 변화와 리팩토링 실수로 인한 변화를 구분하기 어렵다.
보통 리팩토링을 한 다음 기능 변경을 하는 것이 좋다.

### 10.2.3 잘 설명되는 실패

테스트의 주요 목적 중 하나는 미래의 훼손으로부터 코드를 보호하는 것이다.
개발자가 망가뜨린 코드를 모를 수 있기 때문에 테스트 실패가 무엇이 잘못됐는지 알려주지 않는다면
그것을 알아내기 위해 많은 시간을 소모해야한다.

테스트가 코드에서 동작하지 않는 부분을 명확하게 설명하려면 문`제 발생 시 어떤 실패 메시지를 만들어낼지,
그리고 이것이 다른 개발자에게 유용할지 고민`해야한다.
좋은 방법 중 하나는 하나의 테스트 케이스는 한 가지 사항만 검사하고 각 테스트 케이스에 서술적인 이름을 사용하는 것이다.

### 10.2.4 이해할 수 있는 테스트 코드

테스트가 실패하면 원래의 코드가 작동하지 않는다는 것을 가정했다.
하지만, 정확하게는 `테스트 실패는 코드가 다른 방식으로 동작한다는 것`을 나타낸다.
다른 개발자는 새로운 요구 사항을 충족하기 위해 코드의 기능을 의도적으로 수정할 수 있다.
이 경우 동작의 변화는 `의도적`이다.

새로운 기능을 반영하기 위해서는 테스트 코드를 수정해야 한다. 자신이 변경한 사항이 원하는 동작에만 영향을
미친다는 확신을 가지려면 테스트의 어느 부분에 영향을 끼치는지, 테스트 코드에 수정이 필요한지에 대해 알아야 한다.
따라서, 테스트 케이스가 무엇을 테스트하는지 어떻게 테스트하는지 이해할 수 있어야한다.

여기서 발생할 수 있는 문제는 `한번에 너무 많은 것을 테스트 하는 것`과 `너무 많은 공유 테스트 설정을 사용하는 것`이다.
이 두 가지 모두 이해하기 어렵고 추론하기 어려운 테스트로 이어질 수 있따.

테스트 코드를 이해하기 쉽게 만들기 위한 노력의 다른 이유는 개발자들이 테스트를 코드의 `사용 설명서`로 사용하는 경우도 존재하기 떄문이다.

### 10.2.5 쉽고 빠르게 실행

단위 테스트는 `자주 실행`된다. 코드베이스에서 관련 테스트를 통과해야만 병합이 가능한 병합 전 검사를 수행한다.
만약 단위 테스트가 느리다면 자주 수행되는 테스트로 인해 작업 속도가 느려질 수 있다.

테스트를 빠르고 쉽게 유지해야하는 다른 이유는 실제로 `테스트를 할 수 있는 기회를 극대화`하기 위함이다.
테스트를 쉽고 빠르게 실행할 수 있으면 개발자는 더 효율적으로 작업할 수 있고 테스트 역시 더 광범위해진다.

## 10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라

우리의 목표 중 하나가 구현 세부 사항에 대한 테스트를 피하는 것이라면 퍼블릭 API만 사용하여 테스트해야 한다는 것을 의미한다.

`퍼블릭 API만을 사용한 테스트`는 단위 테스트와 관련한 매우 일반적인 조언이다.
세부 사항이 아닌 코드 사용자가 궁극적으로 신경 쓸 동작에 집중하도록 하는 것으로, 세부 사항은
목적을 이루기 위한 수단일 뿐이기 때문이다. 

이 원칙을 따르면 테스트와 구현 세부 정보를 결합하지 않고, 호출하는 쪽에서 실제로 신경 쓰는 사항만 테스트하는데 집중할 수 있다.

### 10.3.1 중요한 동작이 퍼블릭 API 외부에 있을 수 있다

하지만 현실에서는 코드가 이렇게 독립적인 경우는 드물다. 테스트 대상 코드는 수많은 다른 코드에
의존하는 경우가 많은데 의존하는 코드로부터 외부 입력이 제공되거나 테스트 대상 코드가 의존하는 코드에 부수 효과를
일으킨다면 테스트의 의미가 달라질 수 있다.

`어떤 것이 구현 세부 사항인지는 맥락에 따라 달라질 수 있다.` 테스트에 관해서는 퍼블릭 API로 제공되지 않는 것 중에서도
테스트 코드가 알아야 할 다른 사항이 있을 수 있다.

만약 유저의 이메일을 조회하는 기능이 있다고 가정하자.
퍼블릭 API는 주어진 유저 ID로 이메일 주소를 조회하는데 이것이 가장 중요한 동작일 수 있다.
하지만 이를 `서버에서 조회하는 것`을 시뮬레이션 하지 않는다면 이를 `테스트하는 것은 불가능`하다.
서버에서 이메일 주소를 조회하는 것은 `퍼블릭 API의 일부가 아니지만 중요한 동작이므로 테스트` 되어야한다.

가능하면 퍼블릭 API를 사용하여 코드의 동작을 테스트 한다는 것은 `퍼블릭 함수의 매개변수,
반환값, 오류 전달을 통해 발생하는 동작만 테스트해야 한다는 것을 의미`한다.
하지만, 코드의 퍼블릭 API를 어떻게 정의하나야 따라 퍼블릭 API만으로 모든 동작을 테스트할 수 없는 경우도 존재한다.
`다양한 의존성을 설정`하거나 `특정 부수 효과가 발생하는지 여부`를 확인하는 것이 이에 해당할 수 있따.
몇 가지 예는 다음과 같다.

- 서버와 상호작용하는 코드
- 데이터베이스에 값을 저장하거나 읽는 코드

`퍼블릭 API만을 이용해 테스트하라`와 `구현 세부 사항을 테스트하지 말라`는 것은 훌륭한 조언이지만,
이는 원칙일 뿐 구현 세부 사항의 정의는 주관적이고 상황에 따라 달라질 수 있다.
테스트를 구현 세부 사항에 최대한 독립적으로 수행하되 다른 대안이 없는 경우에만 퍼블릭 API를 벗어나 테스트해야한다.

## 10.4 테슽느 더블

의존성을 실제로 사용하는 것에 대한 대안으로 `테스트 더블(test double)`이 있다.
테스트에 적합하게 사용할 수 있도록 만들어진 객체로 목(mock), 스텁(stub), 페이크(fake) 세가지 유형이 존재한다.

### 10.4.1 테스트 더블을 사용하는 이유

- 테스트 단순화
  - 의존성은 많은 설정이 필요하거나 하위 의존성을 설정해야 할 수 있다
  - 의존성을 실제로 사용하는 대신 테스트 더블을 이용해 단순화 할 수 있다
- 테스트로부터 외부 세계 보호
  - 일부 의존성은 실제로 부수 횩화를 발생시킨다
  - 테스트 더블을 사용하면 외부 세계에 있는 시스템을 테스트의 동작으로 부터 보호 가능하다
- 외부로부터 테스트 보호
  - 외부 세계는 비결정적일 수 있다
  - 테스트 더블은 항상 동일하게 결정적 방식으로 작동하도록 설정할 수 있다

### 10.4.2 Mock

목은 클래스나 인터페이스를 시뮬레이션하는 데 멤버 함수에 대한 호출을 기록하는 것 외에는 어떤 일도 수행하지 않는다.
테스트 대상 코드가 `의존성을 통해 제공되는 함수를 호출하는지 검증`하기 위해 목을 사용할 수 있다.
`대상 코드에서 부수 효과를 일으키는 의존성을 시뮬레이션하는데 가장 유용`하다.

테스트로부터 외부 세계를 보호하는데 적합하지만, `테스트가 비현실적이고 중요한 버그를 잡지 못할 위험`이 있다.

### 10.4.3 Stub

스텁은 함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션한다.
스텁은 테스트 대상 코드가 `의존하는 코드로부터 어떤 값을 받아야하는 경우 유용`하다.

### 10.4.4 목과 스텁은 문제가 될 수 있다

목과 스텁의 주요 단점은 다음과 같다

- 목이나 스텁이 실제 의존성과 다른 방식으로 동작하도록 설정되면 테스트는 실제적이지 않다
- 구현 세부 사항과 테스트가 밀접하게 결합하여 리팩토링이 어려워질 수 있다

#### 목과 스텁은 실제적이지 않은 테스트를 만들 수 있다

개발자는 목이나 스텁이 어떻게 동작할지 결정한다. `클래스나 함수가 실제와 다르게 동작하도록 하는 것은 위험`하다.
테스트는 통과하고 모든 것이 잘 작동한다고 착각하지만 코드가 실제로 실행되면 정확하지 않게 동작하거나 버그가 발생할 수 있다.
`실제 의존성이 어떻게 동작하는지 이해하지 못하면 목을 설정할 때 실수할 가능성`이 크다.
스텁을 사용할 때도 마찬가지로 값이 의존성 코드가 실제로 반환하는 값인지에 대해 아무런 검증을 하지 않는다.

#### 목과 스텁을 사용하면 테스트가 구현 세부 정보에 유착될 수 있다

앞서 설명했듯이 목은 의존성을 통해 제공되는 함수가 호출되는지 확인하는데 유용하다.
하지만 리팩토링을 통해 구현 세부 사항이 변경되어 더잇아 해당 함수를 호출하지 않는다면 테스트가 실패하게 된다.
실제 동작은 변경되지 않았지만 테스트가 실패하는 상황이 발생할 수 있다.

따라서 실제 의존성이나 페이크를 사용하는 것이 가능하다면 그렇게 하는 것이 보통 더 바람직하다.

### 10.4.5 Fake

페이크는 클래스의 대체 구현체로 테스트에서 안전하게 사용할 수 있다.

페이크의 요점은 코드 계약이 실제 의존성과 동일하기 때문에 실제 클래스가 특정 입력을 받아들이지 않는다면
페이크 또한 마찬가지라는 것이다. 따라서 실제 의존성에 대한 코드 계약이 변경되면 페이크 또한 변경되어야 한다.

- 페이크로 인해 보다 실질적인 테스트가 이루어질 수 있다
- 페이크를 사용하면 구현 세부 정보로부터 테스트를 분리할 수 있다

### 10.4.6 목에 대한 의견

- 목 찬성론자(mockist)
  - 런던 학파
- 고전 주의자(classicist)
  - 디트로이트 학파
  - 테스트에서 의존성을 실제로 사용하는 것을 최우선으로 해야한다고 주장

작성된 테스트 사이의 주요 차이점은` 목을 사용한 테스트는 상호작용을 테스트`하고,
`고전주의 방법은 코드의 결과 상태와 의존성을 테스트`하는 경향이 있다.

목을 지지하는 주장은 다음과 같다.

- 단위 테스트가 더욱 격리된다
  - 목을 사용하는 것은 테스트가 의존성에 대한 것들을 테스트하지 않는다는 것
  - 특정 코드에 문제가 있을 경우에만 테스트가 실패하며, 이를 의존하는 다른 코드의 테스트는 실패하지 않는다
- 테스트 코드 작성이 더 쉬워진다
  - 의존성을 설정할 필요가 없고 하위 종속성의 설정에 대해 걱정하지 않아도 되기에 설정이 간단

고전주의적 접근법의 주장은 다음과 같다.

- 목은 코드가 실제로 호출이 유효한지 검증하지 않는다. 코드에 문제가 있어도 테스트는 통과할 수 있다
- 구현 세부 사항에 대해 더 독립적으로 테스트 할 수 있다
  - 코드가 반환하는 것이나 상태를 검증하는데 중점을 둔다
  - 대상 코드의 동작이 변경되었을 때에만 실패하며, 구현 세부 사항이 변경됬을 때는 실패하지 않는다

필자는 초기에는 테스트 작성이 쉽다는 이유로 목을 사용헀지만 이를 후회한다.
동작을 제대로 테스트하지 않았고 코드의 리팩토링을 매우 어렵게 만들었기 때문이다.

## 10.5 테스트 철학으로부터 신중하게 선택하라

테스트 철학과 방법론의 몇 가지 예는 다음과 같다.

- 테스트 주도 개발(test-driven development, TDD)
  - 테스트를 먼저 작성하고 그 다음에 코드를 작성하는 방법
  - 실제 코드는 테스트만 통과하도록 최소한으로 작성하고 구조를 개선하고 중복을 없애기 위해 리팩토링
  - 한 테스트 케이스는 하나의 동작만 테스트하도록 집중하며 구현 세부 사항을 테스트하지 않는 등의 사례를 지지
- 행동 주도 개발(behavior-driven development, BDD)
  - 이 철학의 핵심은 사용자, 고객, 비지니스의 관점에서 소프트웨어가 보여야 할 행동을 식별하는데 집중
  - 소프트웨어 자체의 속성보다는 원하는 동작을 반영
- 수용 테스트 주도 개발(acceptance test-driven development, ATDD)
  - BDD와 비슷하지만 정의에 따라 BDD와 겹치는 정도가 다르다 
  - 사용자의 관점에서 소프트웨어가 어떻게 동작해야 하는지에 대한 테스트를 작성

## 요약

- 코드베이스의 거의 모든 코드에 대해 단위 테스트가 동반되어야 한다
- 실제 코드가 보여주는 모든 동작에 대해 테스트를 작성해야 하며 준비, 실행, 단언 세 가지 부분으로 나누는 것이 일반적이다
- 바람직한 단위 테스트의 주요 특징은 다음과 같다
  - 문제가 생긴 코드의 정확한 탐지
  - 세부 구현 사항에 독립적
  - 잘 설명되는 실패
  - 이해할 수 있는 테스트 코드
  - 쉽고 빠르게 실행
- 테스트 더블은 의존성을 실제로 사용하는 것이 불가능할 때 사용
  - mock, stub, fake
- 목과 스텁의 테스트 코드는 비현실적이고 구현 세부 사항에 유착될 수 있다
- 목과 스텁에 대한 여러 의견이 존재하지만, 필자는 가능한 실제 의존성이 테스트에 사용되어야 한다고 생각
  - 이것이 불가능하다면 차선책으로 페이크, 목과 스텁은 최후 수단
