# 6장. 예측 가능한 코드를 작성하라

## 이번 장에서 다루는 내용

- 코드가 어떻게 예측을 벗어나 작동할 수 있는지
- 소프트웨어에서 예측을 벗어나는 코드가 어떻게 버그로 이어지는지
- 코드가 예측을 벗어나지 않도록 보장하는 방법

예측 가능한 코드를 작성하는 것은 무엇인가를 분명하게 하는 것일 떄가 많다.
아무것도 반환하지 않는 함수나 특별히 처리해야 할 로직을 다른 개발자에게 확실히 알려야한다.
코드의 동작이 그들이 `실제 일어날 것이라고 생각하는 것과 일치하지 않을 위험`을 막아야한다.

## 6.1 매직값을 반환하지 말아야 한다.

매직값은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가지고 있다.
일반적으로 값이 없거나 오류가 발생했음을 나타내기 위해 -1을 반환하는 것이 대표적이다.

함수의 정상적인 반환 유형에 들어맞기 때문에 이 값이 갖는 특별한 의미를 인지하지 못하고
정상적인 반환값으로 오해하기 쉽다.

### 6.1.1 매직값은 버그를 유발할 수 있다

일반적으로 매직값을 반환하면 예측을 벗어날 위험이 있으므로 사용하지 않는 것이 가장 바람직하다.
매직값이 사용된 코드가 어디서 어떻게 불리고 있는지 알지 못하면 치명적인지 아닌지를 판단할 수 없다.

또한 단위 테스트에서 해당 문제를 발견하지 못할 수 있다. 
예측을 벗어난 코드를 작성한다면, 해당 코드의 덫에 빠지지 않도록 누군가 모든 상황을 부지런히 확인해야 한다.

### 6.1.2 해결책: 널, 옵셔널 또는 오류를 반환하라

값이 없을 수 있는 경우 코드 계약의 명백한 부분에서 확인할 수 있도록 하는 것이 좋다.
널 안정성을 지원하는 경우 널이 가능한 유형을 반환하고 그렇지 않다면 옵셔널 값을 반환하는 것이다.

널값이나 비어있는 옵셔널은 값이 없는 이유를 명시적으로 전달하지 않는다는 단점이 있지만,
4장에 오류 전달 기법을 사용하면 이를 보완할 수 있다.

### 6.1.3 때때로 매직값이 우연히 발생할 수 있다

매직값은 개발자가 의도적으로 만든 것 외에도 우연히 발생할 수 있다.
개발 중 모든 입력과 입력값들이 어떤 영향을 미칠지 충분히 생각하지 않은 경우에도 발생할 수 있다.

```text
int minValue(List<Integer> values) {
    int minValue = Integer.MAX_VALUE;
    for(int value : values) {
        minValue = Math.min(value, minValue);
    }
    return minValue;
}
```

위 코드에서 values에 빈값이 전달된다면 Integer.MAX_VALUE가 반환된다.
함수가 어떻게 호출되고 결과가 어떻게 사용될지 알수 없기에 그 경우 코드는 예측을 벗어난 동작을 하게된다.

`호출하는 쪽에서는 어떤 입력에 대해서는 값을 계산하지 못할 수 있음`을 알아야한다.
이를 방지하기 위한 코드를 작성해야하지만, 이렇게 함으로써 버그가 발생할 가능성이 있는 코드를 실행할 위험이 없어진다.

## 6.2 널 객체 패턴을 적절히 사용하라

값을 얻을 수 없을 때 널값이나 빈 옵셔널을 반환하는 대신 널 객체 패턴을 사용할 수 있다.
널값을 반환하는 대신 유효한 값이 반환되어 널값으로 인해 시스템에 피해가 가지 않도록 하기 위함이다.

오류 처리이외의 경우에는 널 객체 패턴이 유용하지만, 부적절하게 사용되면 예측을 벗어난 동작을 하거나 발견하기 어려운 미묘한 버그가 발생할 수 있다.

### 6.2.1 빈 컬렉션을 반환하면 코드가 개선될 수 있다

```text
Set<String> getClassnames(HtmlElement element) {
    String? attribute = element.getAttribute("class");
    if (attribute == null) {
        return new Set();
    }
    return new Set(attribute.split(" "));
}

Boolean isElementHiglitghted(HtmlElement element) {
    return getClassnames(element).contains("highlighted");
}
```

위 코드는 코드 품질을 향상시키는 널 객체 패턴의 예이다.
호출하는 쪽의 코드는 간단해지고 코드가 예측을 벗어난 작동을 할 가능성이 매우 낮다.
그러나 복잡한 상황에서는 널 객체 패턴을 사용하는 경우 예측을 벗어나는 동작을 할 위험이 커지고 이점은 적어진다.

### 6.2.2 빈 문자열을 반환하는 것도 때로는 문제가 될 수 있다

빈 컬렉션을 반환하는 것처럼 널 대신 빈 문자열을 반환할 수 있다.
이때는 문자열이 어떻게 사용되는지에 따라 적절한지 아닌지를 알 수 있다.
문자열이 단순히 문자를 모아둔 것에 지나지 않다면 빈 문자열 반환이 적절할 수 있으나, `문자열이 의미를 지닌다면
빈 문자열을 반환하는 것이 문제`가 될 수 있다.

#### 문자들의 모음으로서의 문자열

단지 문자를 모아둔 것에 불과하다면 널 객체 패턴을 사용하는 것이 문제될 것 없다.
호출하는 쪽에서는 반환된 값이 널인지 빈 문자열인지 구별하는 것이 중요하지 않다.

#### ID로서의 문자열

어떤 경우에는 코드에서 특정한 의미를 지닌 문자열을 반환할 수 있다.
이 경우, 문자열이 없을 수 있음을 함수를 호출하는 쪽에서 명시적으로 인식할 수 있도록 하는 것이 중요하다.

### 6.2.3 더 복잡한 널 객체는 예측을 벗어날 수 있다

함수를 호출할 때 널 객체 패턴을 사용하는 것은 본질적으로 빈 상자를 파는 것과 같다.
빈 상자를 받고 놀라거나 당황할 가능성이 있는 코드라면 널 객체 패턴을 피해야한다.

널 객체 패턴의 더 복잡한 형태 중 하나는 클래스를 만들고 무의미한 값을 클래스안에 두는 것이다.

### 6.2.4 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다

## 6.3 예상치 못한 Side effect를 피하라

부수 효과(Side effect)는 어떤 함수의 호출이 함수 외부에 초래한 상태 변화를 의미한다.
함수가 반환하는 값 외에 다른 효과가 있다면 이는 부수 효과이다.

- 사용자에게 출력 표시
- 파일이나 데이터베이스에 무언가를 저장
- 다른 시스템을 호출하여 네트워크 트래픽 발생
- 캐시 업데이트 혹은 무효화

부수 효과는 소프트웨어 작성 시 불가피한 부분이므로 코드 일부에는 부수 효과가 존재한다.
부수 효과가 예상되지 않을 경우 놀라움을 유발하고 버그로 이어질 수 있다.

애초에 부수 효과가 일어나지 않도록 하는 것이 가장 좋지만 이를 피할 수 없는 경우 호출하는 쪽에서
이에 대해 확실하게 인지하도록 하는 것이 중요하다.

### 6.3.1 분명하고 의도적인 부수 효과는 괜찮다
### 6.3.2 예기치 않은 부수 효과는 문제가 될 수 있다

#### 부수 효과는 비용이 많이 들 수 있다

호출하는 작업이 잠재적으로 비용히 많이들 수 있지만, 호출하는 쪽의 개발자는 그 작업이
비용이 많이 드는 작업인지 인지하지 못할 수 있다.

#### 호출한 쪽의 가정을 깨뜨리기

함수명을 보고 함수를 호출할 때 내부적으로 예상과는 다른 동작을 할 수 있다.
예를 들어 getXX라는 함수 내부에 데이터를 바꾸는 코드가 존재할 수 있다.

#### 다중 스레드 코드의 버그

독립적인 여러 작업을 수행할 필요가 있는 경우, 일반적으로 각 작읍을 스레드에서 실행한다.
멀티 스레딩에서 서로 다른 스레드가 동일한 데이터에 액세스할 수 있기 때문에 한 스레드의 부수 효과가
다른 스레드에 문제를 일으킬 수 있다.

### 6.3.3 해결책: 부수 효과를 피하거나 그 사실을 분명하게 하라

먼저 함수의 이름을 명확히하여 부수효과가 발생할 것이라는 점을 명확하게 하라.

정보를 얻는 함수는 일반적으로 부수 효과를 일으키지 않기 때문에 일반적으로 부수효과를 예상하지 않는다.
따라서 어떤 함수가 부수 효과를 일으킨다면 호출하는 쪽에 명확히 전달해야할 책임이 있다.

## 6.4 입력 파라미터를 수정하는 것에 주의하라

### 6.4.1 입력 파라미터를 수정하면 버그를 초래할 수 있다

입력으로 받은 파라미터를 수정하는 것은 함수가 외부의 무언가에 영향을 미치기 때문에 부수 효과를 일으킬 수 있다.
파라미터를 통해 입력을 가져오거나 빌려와서 반환값을 통해 결과를 제공하는 것이 일반적이다.
따라서, 파라미터로 들어온 값을 변경할 것이라고 예상하지 못한다.

### 6.4.2 해결책: 변경하기 전에 복사하라

입력 파라미터 내의 값을 어쩔 수 없이 변경해야 하는 경우 변경 전에 새로운 자료구조에 복사하는 것이 최선의 방법이다.
값을 복사하면 리소스에 영향을 미칠 수 있지만, 예상치 못한 버그와 비교하면 크게 문제되지 않는다.

하지만 많은 양의 데이터와 같이 성능상에 이유로 복사를 할 수 없지만 변경을 해야하는 경우,
함수 이름과 문서에 이러한 일이 발생한다는 점을 분명하게 명시하라

## 6.5 오해를 일으키는 함수를 작성하지 말라

### 6.5.1 중요한 입력이 누락되었을 때 아무것도 하지 않으면 놀랄 수 있다

파라미터가 없더라도 호출할 수 있고 해당 파라미터의 값이 없다면 아무 작업도 수행하지 않는 함수가 있다면,
이 함수는 수행하는 작업에 대해 오해의 소지가 있을 수 있다.

### 6.5.2 해결책: 중요한 입력은 필수 항목으로 만들라

중요한 파리미터가 널이 가능한 값을 받아들일 수 있게 하면 호출하는 쪽은 널값을 확인하지 않아도 되기에 코드가 간결해질 수 있다.
하지만 이는 오해를 불러일으키고 버그로 이어질 수 있다.

널 확인 코드가 코드의 라인 수를 증가시킬 수 있지만, 코드를 명확하게 작성하는 것의 이점은 코드 라인 몇 줄 보다 값지다.

## 6.6 미래를 대비한 열거형 처리

이전까지는 우리의 코드에 의존하는 코드가 올바르게 동작하기 위해 초점을 맞췄다.
하지만 우리가 다른 코드에 의존하는 경우에도 우리의 예상을 벗어나는 결과를 초래할 수 있다.

대표적으로 열거형의 경우 나중에 열거형에 더 많은 값이 추가될 수 있다는 점을 반드시 명심해야한다.

### 6.6.1 미래에 추가될 수 있는 열거값을 암묵적으로 처리하는 것은 문제가 될 수 있다.

열거형을 if문을 통해 처리할 수 있는데 현재의 값에 대해서는 문제가 없지만, 나중에 다른 값이 추가되면 문제가 생길 수 있다.

### 6.6.2 해결책: 모든 경우를 처리하는 스위치 문을 사용하라

더 나은 접근법은 열거값을 명시적으로 처리하고 처리되지 않은 새로운 열거값이 추가되는 경우 컴파일이 실패하거나
테스트에 실패하는 것이다. 모든 값을 다 처리하는 스위치 문을 사용함으로써 코드가 예측을 벗어나 동작하거나
잠재적으로 치명적인 버그가 발생하지 않도록 방지할 수 있다.

### 6.6.3 기본 케이스를 주의하라

스위치 문은 일반적으로 처리되지 않는 모든 값에 대해 default 케이스를 정의할 수 있다.
default 케이스를 추가하면 향후 열거값이 추가되더라도 암묵적으로 처리되므로 문제가 발생할 수 있다.

### 6.6.4 주의 사항: 다른 프로젝트의 열거형에 의존

다른 프로젝트나 조직이 개발한 코드의 열거형을 사용하는 경우 사용자에게 알려지지 않은 상태에서
열거값이 추가될 수 있고 이로인해 기존 코드가 동작하지 않을 수 있다.

## 6.7 이 모든 것을 테스트로 해결할 수 없는가?

- 어떤 개발자들은 테스트에 대해 부지런하지 않을 수 있다
  - 시나리오가 틀렸음을 검증하는 코너 케이스에 대한 충분한 테스트가 없을 수 있다
- 테스트가 항상 정확히 시뮬레이션 되는 것이 아니다
  - 보통 목 객체를 통해 테스트하는 경우, 목 객체가 어떻게 행동할 것인지 `자신이 생각하는 바대로 작성`된다.
  - 실제 코드가 가정과 예측을 벗어나 동작하지만 이를 깨닫지 못할 수 있다
- 어떤 것은 테스트하기 어려울 수 있다

테스트는 매우 중요하다. 코드 구조화나 코드 계약도 고품질의 테스트를 대체할 수 없다.
하지만, 직관적이지 않거나 예상을 벗어나는 코드에 `숨어있는 오류를 테스트만으로는 방지하기 어렵다`.

## 요약

- 다른 개발자가 작성하는 코드는 종종 우리가 작성하는 코드에 의존한다
- 우리가 사용하는 코드에 대해 허술하게 가정하면 예상을 벗어나는 또다른 결과가 나타날 수 있다
  - 열거형
  - 코드가 가정을 벗어난 경우 컴파일을 중지하거나 테스트에 실패하면 좋다
- 테스트만으로는 예측을 벗어나는 코드의 문제를 해결할 수 없다
  - 다른 개발자가 코드를 잘못 해석하면 테스트 시나리오도 잘못 이해할 수 있다