# 3장. 다른 개발자와 코드 계약

## 이 장에서 다루는 내용

- 다른 개발자들이 코드와 어떻게 상호작용하는지
- 코드 계약과 코드 계약의 세부 조항
- 세부 조항을 최소화하는 것이 어떻게 오용과 예측을 벗어나는 코드를 에방하는데 도움이 되는지
- 세부 조항을 피할 수 없다면 체크와 어서션을 어떻게 사용할 수 있는지

1장에서 다룬 내용 중 `예측 가능한 코드를 작성하라`와 `코드를 오용하기 어렵게 만들라`는
원칙이 존재하는데, 이는 모두 다른 사람이 작성한 코드와 상호작용할 때 일어 날 수 있다.

## 3.1 자신의 코드와 다른 개발자의 코드

고품질 코드를 작성할 때 중요한 고려 사항 중 하나는 다른 개발자가 변경하거나 `코드와 상호작용할 때 발생할 수 있는 문제`가 없는지,
또 발생한다면 그 `문제를 어떻게 완화할 수 있을지`를 이해하고 선제적으로 조치하는 것이다.

코드 작성 시 다음 세 가지를 고려하는 것이 유용하다

- 자신에게 명백하다고 다른 사람에게도 명백한 것은 아니다
- 다른 개발자는 무의식 중에 코드를 망가뜨릴 수 있다
- 시간이 지남에 따라 자신의 코드를 기억하지 못한다

### 3.3.1 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다

코드를 작성하기 시작하면 설계, 테스트, 제품 피드백, 오류 등 여러 단계를 거치고 자신의 로직에 대해
익숙해져서 모든 것이 분명해 보인다.

하지만 상대방은 문제를 이해하고 어떻게 해결할지 충분한 시간을 갖지 못한 상태일 수 있다.
따라서 코드가 어떻게 사용되어야 하는지, 무엇을 하는지, 왜 그 일을 하는지를 설명하는 것이 유용하다.
코드를 이해하기 쉽고 코드 자체로 설명이 되게 하는 것이 좋은 방법이다.

### 3.1.2 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다

코드는 다른 코드로부터 독립적인게 아니라 끊임없이 변화되기 떄문에, 내가 작성한 코드를 기반으로
계속 변화하는 코드가 작성된다. 따라서, 다른 개발자가 의도치 않게 잘 실행되던 코드를 작동하지 않게하거나 오용하는 방식으로 수정할 가능성이 있다.

이를 방지하기 위해 두가지 방법이 존재한다.

- 문제가 있을 때 코드 컴파일이 중지
- 문제가 있을 때 테스트가 실패

### 3.1.3 시간이 지남에 따라 자신의 코드를 기억하지 못한다

일정 시간이 지나게되면 자신에게는 분명했지만 다른 사람에게는 분명하지 않았던 문제가 자신에게 적용된다.
따라서 명확한 코드 작성은 미래의 나에게도 중요한 일이다.

## 3.2 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?

코드를 사용하거나 작성한 코드에 의존하는 코드를 수정할 때 그 코드가 무슨 일을 하는지 파악해야 한다.
다음과 같은 사항을 이해할 필요가 있다

- 여러 가지 상황에서 어떤 함수를 호출해야 하는지
- 클래스가 무엇을 나타내는지
- 클래스가 언제 사용되어야 하는지
- 어떤 값을 파라미터로 사용해야 하는지
- 코드가 수행하는 동작이 무엇인지
- 어떤 값을 반환하는지

### 3.2.1 이름 확인

패키지, 클래스, 함수의 이름은 책의 목차라고 볼 수 있다. 다른 개발자가 어떻게 사용하는지 대해
가장 잘 전달할 수 있는 방법은 이름을 잘 지어주는 것이다.

### 3.2.2 데이터 유형 확인

컴파일 언어에서는 데이터 유형을 인식하고 올바르게 사용해야한다. 다른 개발자가 코드를 오용하거나 오작동할 수 없도록
하는 좋은 방법이다.

### 3.2.3 문서 읽기

문서는 두 가지 이상의 형태로 존재할 수 있으며 다음을 포함한다.

- 함수 및 클래스 수준의 비공식적인 주석문
- 자바독과 같은 좀 더 공식적인 코드 내 문서
- 외부 문서

이 방법은 다음과 같은 이유로 어느정도 까지만 신뢰할 수 있다.

- 다른 개발자가 문서를 읽으리란 보장이 없음
- 읽더라도 잘못 해석할 수 있음
- 문서의 업데이트가 제대로 안될 수 있음

### 3.2.4 직접 물어보기

이 방법은 다음과 같은 이유로 신뢰하기 어려운 방법이다.

- 코드를 많이 작성할 수록 질의에 필요한 시간이 늘어난다
- 코드 작성자가 휴가를 갈 수 있다
- 시간이 지나면 코드 작성자도 해당 코드를 기억할 수 없다
- 코드 작성자가 회사를 떠날 수 있다

### 3.2.5 코드를 살펴보는 것

가장 확실한 답을 얻는 방법일 수 있지만, 실용적이지 못하며 코드의 양이 늘어날수록 비효율적이다.

## 3.3 코드 계약

계약에 의한 프로그래밍 또는 계약에 의한 디자인이라고 불리는 개념으로 다른 사람들이 어떻게 코드를 사용할지,
코드가 무엇을 할 것으로 기대하는지에 대한 것이다. 서로 다른 코드 간의 상호작용을 마치 계약처럼 생각한다.
계약에서 정의되기 떄문에 분명하지 않은 것이 없고 예쌍과 다르게 실행되는 것도 없다.

코드 계약에 대한 용어를 세 가지 범주로 나누면 유용하다.

- 선결 조건
  - 코드를 호출하기 전에 사실이어야 하는 것
  - 시스템이 어떤 상태여야 하는가, 어떤 입력을 공급해야 하는가
- 사후 조건
  - 코드가 호출된 후에 사실이어야 하는 것
  - 시스템이 새로운 상태에 놓이거나 반환되는 값
- 불변 사항
  - 코드가 호출되기 전과 후에 변경되지 않는 사항

### 3.3.1 계약의 세부조항

- 계약의 명확한 부분
  - 함수와 클래스 이름
  - 파라미터 유형
  - 반환 유형
  - 검사 예외(check exception)
    - 호출하는 코드가 이를 처리하지 않으면 컴파일 에러
- 세부 조항
  - 주석문과 문서
  - 비검사 예외(uncheck exception)
    - 호출하는 코드가 이를 처리하지 않아도 컴파일 에러가 발생하지 않음
    - 주석문에 해당 예외가 나열되면 세부조항이다

조건을 명백하게 하는 것이 세부 조항을 사용하는 것보다 낫다.

### 3.3.2 세부조항에 너무 의존하지 말라

- 세부 조항을 제거하는 방법
  - 잘못도니 일을 하는 것을 처음부터 불가능하게 만드는 것이 베스트
  - 코드가 오용되거나 잘못 설정되면 컴파일조차 되지 않도록 하는 것이 목표

## 3.4 체크 및 어서션

컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 컴파일 타임 확인만큼 강력하진 않지만 런타임 검사를 사용할 수 있다.
그럼에도 런타임 검사를 사용하는 것이 아예 확인하지 않는 것 보다 낫다

### 3.4.1 체크

준수되지 않을 경우 체크는 실패를 유발하는 오류를 발생시키며 놓치고 넘어가는 것이 불가능하다.
체크는 계약 조건에 따라 다음과 같은 범주로 나뉜다.

- 전제 조건 검사
  - 코드를 실행하기 전 시스템이 유효한지, 파라미터 검사
- 사후 상태 검사
  - 반환 값이 올바른가, 시스템이 유효한 상태인가

하지만 체크를 사용해도 효과가 반드시 보장되는 것은 아니다.

- 테스트하기 불분명한 상황에서 해당 조건이 위반된다면 사용자가 실행전 까지 알 수 없다
- 체크가 잘 동작되더라도 시스템 작동을 멈추지 않기위해 상위 수준에서 예외를 처리할 수 있다

체크가 많이 존재한다면 세부 사항을 없애는 것에 대해 고려해야할 수 있다.

### 3.4.2 어서션

어서션은 언어 차원에서 지원하며 체크와 거의 같은 방식으로 동작한다.
차이점은 배포를 위한 빌드에서 어서션은 보통 컴파일에서 제외되며 실제 서비스에서느 실패를 명확하게 보여주지 않는다.
배포에서 이를 컴파일하지 않는 이유는 다음과 같다.

- 성능 향상을 위해
- 코드 오류 발생률을 낮추기 위해
  - 고가용성이 중요한 시스템의 경우

## 요약

- 다른 개발자가 어떻게 코드를 해석하고 오용할 수 있는지 생각해보고 이를 최소화하기 위해 노력하자
- 코드를 작성할 때 일종의 코드 계약이 항상 만들어진다.
  - 여기에는 명백한 항목이나 세부 조항이 포함된다
- 코드 계약의 세부 조항은 신뢰할만한 방법이 아닐 수 있다
- 컴파일러를 사용해 계약을 확인하는 것이 가장 신뢰할 만한 방법이다
  - 이것이 불가능하면 체크나 어서션을 통해 런타임에서 확인해야 한다
