# 9장. 코드를 재사용하고 일반화할 수 있도록 하라

## 이번 장에서 다루는 내용

- 안전하게 재사용할 수 있는 코드 작성 방법
- 다양한 문제를 해결하기 위해 일반화된 코드를 작성하는 방법

상위 수준의 문제를 세분화해서 해결하는 방법을 진행하다보면 종종 동일한 하위 문제들이 반복적으로 나타나는 경우가 존재한다.
이미 주어진 하위 문제를 해결했다면, 해결책을 재사용하는 것이 시간을 절약할 수 있고 이미 테스트되었기 떄문에 안전하다.

하지만 하위 문제에 대한 해결책이 존재한다고 해서 항상 재사용할 수 있는 것은 아니다.
해당 해결책이 다른 기능과 함께 구성되어 있을 수도 있고 자신의 사례와 맞지 않을 수 도 있다.
따라서 이를 고려하여 재사용이 가능하도록 코드를 작성하고 구조화하는 것이 좋다.

간결한 추상화 계층을 만들고 코드를 모듈화하는 것과 관련이 있다. 
간결한 추상화 계층을 구현하면 하위 문제의 해결책이 느슨하게 결합하는 코드로 나눠어지는 경향이 있다.
이를 통해 코드를 재사용하고 일반화하기 쉬워지며 안전해진다.

## 9.1 가정을 주의하라

코드 작성 시 가정을 하면 코드가 단순해지고 효율적이 된다. 하지만 가정으로 인해 코드가 취약해지고
활용도가 낮아져 재사용에 적합하지 않아질 수도 있다. 어떤 가정이 이루어졌는지 추적하는 것은 어렵기 떄문에
재사용하는 경우 의도한 것과 다른 동작이 될 수도 있다.

코드를 작성할 때 가정으로 초래될 비용과 이점을 고려해야한다.

### 9.1.1 가정은 코드 재사용시 버그를 초래할 수 있다

예를 들어 Article 클래스가 존재하고 getAllImages()라는 함수를 통해 기사에 포함된 이미지를 가져온다.
이때 섹션당 이미지는 하나라는 가정을 하게되고 이를 기반으로 동작한다고 하자.
이 가정을 통해 성능이 미비하게 증가되지만 다른 사람은 getAllImages()라는 함수를 통해 말그대로 모든 이미지를 가져올 것이라 생각한다.
그런 생각을 가지고 해당 함수를 재사용하는 경우 문제가 발생할 수 있다.

보통 가정은 코드 깊숙한 곳에 주석문으로 존재하기에 호출하는 쪽에서 이를 인지할 가능성이 매우 낮다.

### 9.1.2 해결책: 불필요한 가정을 피하라

가정을 통해 성능 향상이 있을 수 있지만 다른 한편으로는 재사용하거나 요구 사항이 변경되면 버그가 발생할 가능성이 있다.
그러나 코드에 가정이 들어가면 취약성 측면에서 비용을 수반한다는 것을 기억해야한다.

가정을 통해 눈에띄는 성능 향상이나 코드가 크게 단순화된다면 그 가정은 가치가 있다.
하지만 가정으로 인한 이득이 미미하다면, 다른 비용이 이점을 초과할 수 있다.

#### 섣부른 최적화

코드 최적화는 비용이 든다. 최적화된 해결책 구현을 위한 시간과 노력이 필요하며 결과적으로
가독성이 떨어지고 유지 보수가 어려워지고 가정으로 인해 견고함이 떨어질 수 있다.

보통 최적화는 프로그램 내에서 수 천번, 수 만번 실행되는 코드에 대해 이뤄질 때 이점을 지닌다.
큰 효과가 없는 코드 최적화를 하느라 애쓰는 것보다 가독성을 높이고 유지보수와 견고함을 신경쓰는게 더 좋다.
물론 성능 향상에 큰 효과를 볼 수 있는게 명백할 때는 최적화 작업을 해도 무방하다

### 9.1.3 해결책: 가정이 필요하면 강제적으로 하라

우리가 세운 가정으로 인해 다른 개발자가 곤란하지 않도록 가정을 강제적으로 시행해야 한다.

1. 가정이 깨지지 않게 하라
   - 가정이 꺠지면 컴파일되지 않는 식으로 가정을 유지시키기
2. 오류 전달 기술을 사용하라
   - 가정을 꺠는 것이 불가능하게 할 수 없다면 오류를 발생시키기

## 9.2 전역 상태를 주의하라

전역상태 또는 전역변수는 실행되는 프로그램 내의 모든 컨텍스트 사이에 공유된다.

전역 변수는 프로그램 내의 모든 컨텍스트에 영향을 미치기 때문에 전역변수를 사용할 때는 누구도
해당 코드를 다른 목적으로 재사용하지 않을 것이라는 `암묵적인 가정`을 전제한다. 앞서 살펴봤듯이 가정에는 비용이 수반된다.

### 9.2.1 전역 상태를 갖는 코드는 재사용하기에 안전하지 않을 수 있다

#### 누군가가 이 코드를 재사용하려고 하면 어떻게 되는가?

우리는 원래의 가정이 꺠지는 여러 상황을 유추할 수 있다.
요점은 원래의 가정이 취약하고 어느 시점에 이르면 그 가정을 깨뜨리는 여러 시나리오가 존재한다는 것이다.

### 9.2.2 해결책: 공유 상태에 의존성을 주입하라

의존성 주입은 전역 상태를 사용하는 것보다 더 통제된 방법으로 서로 다른 클래스 간에 상태를 공유하는 좋은 방법이다.

전역 변수가 프로그램의 여러 부분간 정보를 공유하는 빠르고 쉬운 방법으로 보일 수 있지만,
이는 코드 재사용이 전혀 안전하지 않을 수 있다.

프로그램의 서로 다른 부분 간에 상태를 공유해야 할 경우, 의존성 주입을 사용해 보다 통제된 방식으로 수행할 수 있다.

## 9.3 기본 반환값을 적절하게 사용하라

합리적인 기본값은 사용자 친화적인 소프트웨어를 만들기위한 좋은 방법이다.
기본값을 제공하려면 다음 두 가지 가정이 필요하다.

- 어떤 기본값이 합리적인가
- 더 상위 계층의 코드는 기본값을 받는지 명시적으로 설정된 값을 받는지 상관하지 않는다

상위 수준의 코드는 특정 사용 사례에 더 밀접하게 결합하므로 코드의 모든 용도에 맞는 기본값을 선택하기 더 쉽다.

### 9.3.1 낮은 층위의 코드의 기본 반환값은 재사용성을 해칠 수 있다
### 9.3.2 해결책: 상위 수준의 코드에서 기본값을 제공하라

## 9.4 함수의 매개변수를 주목하라

함수가 데이터 객체나 클래스 내의 모든 정보가 함수에서 필요한 경우 해당 객체나 클래스를
파라미터로 받는 것은 타당할 수 있다. 하지만, 한두 가지 정보만 필요로하는 경우 객체 전체를
파라미터로 넘기는 것은 코드 재사용성을 해칠 수 있다.

### 9.4.1 필요 이상으로 매개변수를 받는 함수는 재사용하기 어려울 수 있다
### 9.4.2 해결책: 함수는 필요한 것만 매개변수로 받도록 하라

일반적으로 함수가 필요한 것만 받는 코드는 재사용성이 향상되고 이해하기 쉽다.

하지만 이는 상황에 따라 달라질 수 있다. 예를 들어 10가지 중 8개 또는 5개의 정보가 필요한 경우
객체를 넘기는 것이 좋을수도 아니면 특정 값들만 파라미터로 넘기는 것이 좋을 수도 있다.
모든 상황에 적용되는 한가지 정답은 없으며 취하는 방법의 장단점을 고려해 적용해야 한다.

## 9.5 제네릭의 사용을 고려하라

많은 언어가 제네릭 혹은 템플릿을 지원한다. 제네릭을 통해 참조하는 모든 유형을 구체적으로
명시할 필요 없이 클래스를 작성할 수 있다.

다른 클래스를 참조하는 코드를 작성하지만 그 클래스가 어떤 클래스인지 신경쓰지 않는다면 제네릭을 고려해야한다.
```text
List<String> list = ["a", "b", "c"];
List<Integer> list = [1, 2, 3];
```

### 9.5.1 특정 유형에 의존하면 일반화를 제한한다

단어 맞히기 게임을 예로들면 String 값으로 유형을 제한할 수 있다.
하지만, 이를 사진 맞히기 게임으로 변경하는 경우 하위 문제는 거의 동일하지만 제한된 유형으로 인해 재사용이 어려울 수 있다.

### 9.5.2 해결채기

하위 문제에 대한 해결책이 모든 데이터 유형에 쉽게 적용될 수 있을 때 특정 유형에 의존하는 대신
제네릭을 사용하더라도 추가적인 노력이 거의 들지 않는다. 더 일반화되고 재사용이 가능하다는 측면에서 쉽게 효과를 볼 수 있다.

## 요약

- 동일한 하위 문제가 자주 발생하므로 코드를 재사용하면 시간과 노력을 줄일 수 있다
- 다른 개발자가 특정 하위 문제를 재사용할 수 있도록 근본적 하위 문제를 식별하고 코드를 구성하도록 노력해야한다
- 간결한 추상화 계층을 만들고 모듈화하면 재사용과 일반화가 쉬워진다
- 가정을 하게되면 코드는 종종 취약해지고 재사용이 어려워질 수 있다
  - 가정을 사용하는 경우 이점이 비용보다 큰지 확인해라
  - 가정을 해야하는 경우 가정이 코드의 적절한 계층에서 이루어지는 확인하고 가능하다면 가정을 강제하라
- 전역 상태를 사용하는 것은 비용이 많이드는 가정을 하는 것이고 재사용이 안전하지 않다
  - 대부분의 경우 전역상태를 피하라
