# RDBMS_Modeling

## 관계형 데이터베이스 (Relational Database)

## 특징

1. 고유 식별자
   - 테이블이 각 행(레코드)를 식별하기 위한 고유 식별자(Key)를 정의할 수 있다

2. 참조 무결성
   - 테이블과 테이블간의 관계에서 나타난다
   - 참조되는 테이블의 외래 키값은 참조하는 테이블에 정의된 고유 식별자의 값의 범위(도메인)를 벗어날 수 없다

### Table(Entity)

Column 속성 여러 개로 구성된 레코드들의 집합
- Column
  - 테이블의 속성들의 집합 
  - 세로열 데이터
  - 필드, 속성
- Row
  - 하나의 속성들의 집합을 모아놓은 행 
  - 가로열 데이터
  - 튜플, 레코드

### Primary Key(주 식별자, PK)

테이블 등록 시 명시해 주어야하는 속성이며, 하나의 레코드를 고유하게 구분할 수 있는 것이다.

- 주로 ID를 예로 생각할 수 있다
- Not Null & Unique 
- Key는 key에 대응하는 인덱스 테이블(index)이 생성된다
  - 인덱스 테이블은 키 값에 의해서 정렬되어 있다.
  - 빠른 검색을 위해
- Determinant
  - 이 값을 알면 나머지 속성 값도 알 수 있다
  - 즉, dependency가 존재한다
- `PK가 없으면 관계를 설정할 수 없다`

## Primary Key 설계

### 고려사항

- 유일하고, 모든 레코드에 `NOT NULL`인 컬럼을 찾아야한다
  - 후보 식별자가 없는 경우 임의의 식별자를 만들어 부여할 수 있다 (인조식별자)
  - 사실 이런 경우가 더 많다
- PK의 데이터 타입 결정
  - 레코드의 발생 가능한 최대 수를 예측해야한다
    - 한달에, 1년에 몇 개 정도 발생하는가?
    - 처리해야하는 대상이 대략 몇 개정도 되는가?
  - int 등의 숫자를 PK로 채택할 경우 자동 증가 속서을 사용할 수 있다
    - 특별한 의미를 부여해야하는 경우 String을 사용하고, 이외에는 정수형이 바람직하다.

> PK를 구성하는데 반드시 하나의 column만을 사용하는 것은 아니다.
> 한 개 이상들의 column들이 모여서 unique & notnull을 만족하면 여러 개의 column을 묶어서 PK로 사용하는 경우도 존재한다.
  
## Relation(관계)

### 1:M 관계

- 부모 - 자식 관계, 종속관계, 트리구조, Has-A 관계
- 하나의 테이블이 다른 테이블의 여러 객체를 갖는 것을 의미한다
  - 가장 흔하게 나타나는 매우 일반적인 관계
- 관계가 있는 테이블에서, 1:M에서 1테이블의 PK가 M테이블의 foreign key(FK)가 된다
  - `참조 무결성`: FK는 PK의 범주에서 벗어날 수 없다

### 1:M의 재귀적인 관계

- 1 : M관계의 M이 1이 되어 하위의 N을 가지는 관계
  - 분류 코드
    - 대분류, 중분류, 소분류
  - 디렉토리
- 이 경우 어떻게 테이블을 구현해야할까?
  - 자기 테이블내에 자기 자신을 가리키는 PK와 FK를 동시에 가지는 방법
    - 부서 ID(PK), 부서명, 상위 부서 ID(FK)
    - 상위 부서 ID는 FK이지만, 결과적으로 같은 테이블의 PK를 가리킨다
  - 즉 한 테이블내에, 모든 데이터가 저장된다

### M:N 관계

- 한 테이블에서 다른 테이블을 봐도 1:M, 반대 테이블에서 봐도 1:M인 관계
  - 학생과 과목 테이블을 생각해보면, 학생은 여러 과목을 수강할 수 있다
  - 과목입장에서도 한 과목에 여러학생이 등록될 수 있다.
- 그런데 생각해보면, PK와 FK와의 관계를 통해 RDBMS가 구성되는데 이 경우는 어떻게 되는걸까?
  - 이를 해결하기 위해선 `중간 테이블` 한 개 필요하다
  - 학생 <-> 수강신청 <-> 과목
- `M:N을 1:M + M:1 관계로 나눠줘야한다`
- M:N 관계는 사실상, 관계가 없는 두 테이블을 특정 비지니스로직을 넣는 경우 발생한다.
  - 따라서 관계없는 두 테이블간에 중간 테이블을 이용해 관계를 연결해줄 수 있다.

> 중간 테이블 또한 Sequence가 PK가 되어 다른 테이블의 FK가 될 수 있다

### 1:1 관계

- 어느 쪽 테이블에서 반대 테이블을 보더라도 단 하나씩 관계를 가지는 관계
  - 개념상 하나로 합치는 것은 가능하지만, PK가 두 개 나오게된다
- 두 개의 테이블로 나뉘어진, 개념적으론 하나의 테이블이다라고 생각하면 편하다
  - 하나의 테이블인 경우 다른 테이블과의 관계를 개별적으로 확장하기 어렵다
- 공통된 데이터 테이블과 세부정보가 다른 테이블간의 관계를 설명할 때 사용한다.

## 정규화

### 데이터 이상현상(Anomaly)

- 데이터 모델링에서 제일 중요한건 무결성을 보장하는 것이다
- 관계가 정립되지 않은 테이블에서 발생할 수 있는 현상
- 중복 때문에 DML을 수행할 때 이상현상이 발생할 수 있다
  - Update, delete, insert에서 발생할 수 있다
- 정규화를 진행하게 되면 중복이 나타날 수 없다

### 1정규화 (No Repeating Group)

- 개요 
  - 데이터 중복을 제거하기 위한 테이블 분할 
  - 고유 식별자가 결정된다 = Primary Key(PK)
  - 1 : M 관계가 형성된다
- 상세
  - 모든 속성은 반드시 하나의 값을 가져야한다
  - 즉, 값이라는 것은 원자성을 가지고 더 이상 나눌 수 없는 하나의 값 만을 가져야한다
  - 다가 속성
    - 같은 종류의 값을 여러개 가지는 속성
    - ex) 한 고객이 여러 전화번호를 가지는 경우
  - 복합 속성
    - ex) 고객명은 성과 이름으로 구성된 복합속성
  - 유사 속성, 중첩, 동일속성이 여러 릴레이션에 존재
    - 동일한 패턴이 반복되게되면 독립시켜줘 1정규화를 진행

### 2 정규화 (Whole Key Dependent)

- 개요
  - 두 개 이상으로 구성된 PK에서 발생한다
  - 식별자(PK) 일부에 종속되는 attribute는 제거해야한다.
  - 종속되는 관계를 가진 컬럼만을 독립시킨다
- 상세
  - 일반 속성이 후보 식별자 전체에 종속되지 않고 일부에 종속된다면 2정규형이 아님
  - 따라서, 모든 비 실별자 속성(일반 컬럼) 후보 식별자 속성에 완전 종속되어야한다
- 방법
  - `일반 속성 중`에서 후보 식별자 전체에 `종속적이지 않은 속성`을 기본 엔티티에서 제거하여, `새로운 상위 엔티티를 생성`

### 3 정규화 (Non-Key Independent)

- 개요
  - 식별자 이외에 속성간에 종속 관계가 형성되면 안된다
  - 종속 관계가 존재하면, 중복 값이 생길 수 있다
  - 이행 종속 관계를 분해하는 것이 3정규화
  - 2정규화와 마찬가지로 종속 관계가 생긴 컬럼을 독립 시킨다
- 상세
  - 식별자가 아닌 일반 속성간의 종속성은 `이행 종속 속성`
  - 일반 속성간의 종속관계를 분해하는 것이 목표

> BC 정규화  
> 일반 속성이 결정되니 PK 그룹 중 하나가 결정되는 상황  
> 일반 속성에 의해 결정되는 PK를 분리해 일반 속성이 PK가 되는 테이블을 만들고, 기존 테이블의 FK로 관계를 형성한다 

### 역정규화

중복을 없애기 위해 정규화를 진행했으나, 그 중 일부러 중복을 만드는 과정이 필요한 경우 `역정규화`가 필요

- 가장 중요한 것은 `효율`
  - 정규화된 결과의 일부를 수정하여 중복을 허용
  - 여기서 중요한건, 정규화되지 않은 상태에서 중복을 허용하는 것과는 다르다는 것
- `JOIN`시 발생되는 수많은 계산량을 해결하기 위해 사용된다
  - 즉, 관계가 있는 테이블에서 서로 자주 참조하는 컬럼이 존재한다면, 중복되는 컬럼을 각 테이블에 만들어, JOIN에서 발생하는 계산량을 줄이겠다